// CODE GENERATED BY github.com/golingon/lingon. DO NOT EDIT.

package aws_ce_cost_category

import (
	terra "github.com/golingon/lingon/pkg/terra"
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
)

type Rule struct {
	// Type: string, optional
	Type terra.StringValue `hcl:"type,attr"`
	// Value: string, optional
	Value terra.StringValue `hcl:"value,attr"`
	// RuleInheritedValue: optional
	InheritedValue *RuleInheritedValue `hcl:"inherited_value,block"`
	// RuleRule: optional
	Rule *RuleRule `hcl:"rule,block"`
}

type RuleInheritedValue struct {
	// DimensionKey: string, optional
	DimensionKey terra.StringValue `hcl:"dimension_key,attr"`
	// DimensionName: string, optional
	DimensionName terra.StringValue `hcl:"dimension_name,attr"`
}

type RuleRule struct {
	// RuleRuleAnd: min=0
	And []RuleRuleAnd `hcl:"and,block" validate:"min=0"`
	// RuleRuleCostCategory: optional
	CostCategory *RuleRuleCostCategory `hcl:"cost_category,block"`
	// RuleRuleDimension: optional
	Dimension *RuleRuleDimension `hcl:"dimension,block"`
	// RuleRuleNot: optional
	Not *RuleRuleNot `hcl:"not,block"`
	// RuleRuleOr: min=0
	Or []RuleRuleOr `hcl:"or,block" validate:"min=0"`
	// RuleRuleTags: optional
	Tags *RuleRuleTags `hcl:"tags,block"`
}

type RuleRuleAnd struct {
	// RuleRuleAndCostCategory: optional
	CostCategory *RuleRuleAndCostCategory `hcl:"cost_category,block"`
	// RuleRuleAndDimension: optional
	Dimension *RuleRuleAndDimension `hcl:"dimension,block"`
	// RuleRuleAndTags: optional
	Tags *RuleRuleAndTags `hcl:"tags,block"`
}

type RuleRuleAndCostCategory struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleAndDimension struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleAndTags struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleCostCategory struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleDimension struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleNot struct {
	// RuleRuleNotCostCategory: optional
	CostCategory *RuleRuleNotCostCategory `hcl:"cost_category,block"`
	// RuleRuleNotDimension: optional
	Dimension *RuleRuleNotDimension `hcl:"dimension,block"`
	// RuleRuleNotTags: optional
	Tags *RuleRuleNotTags `hcl:"tags,block"`
}

type RuleRuleNotCostCategory struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleNotDimension struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleNotTags struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleOr struct {
	// RuleRuleOrCostCategory: optional
	CostCategory *RuleRuleOrCostCategory `hcl:"cost_category,block"`
	// RuleRuleOrDimension: optional
	Dimension *RuleRuleOrDimension `hcl:"dimension,block"`
	// RuleRuleOrTags: optional
	Tags *RuleRuleOrTags `hcl:"tags,block"`
}

type RuleRuleOrCostCategory struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleOrDimension struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleOrTags struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleTags struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type SplitChargeRule struct {
	// Method: string, required
	Method terra.StringValue `hcl:"method,attr" validate:"required"`
	// Source: string, required
	Source terra.StringValue `hcl:"source,attr" validate:"required"`
	// Targets: set of string, required
	Targets terra.SetValue[terra.StringValue] `hcl:"targets,attr" validate:"required"`
	// SplitChargeRuleParameter: min=0
	Parameter []SplitChargeRuleParameter `hcl:"parameter,block" validate:"min=0"`
}

type SplitChargeRuleParameter struct {
	// Type: string, optional
	Type terra.StringValue `hcl:"type,attr"`
	// Values: list of string, optional
	Values terra.ListValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleAttributes struct {
	ref terra.Reference
}

func (r RuleAttributes) InternalRef() (terra.Reference, error) {
	return r.ref, nil
}

func (r RuleAttributes) InternalWithRef(ref terra.Reference) RuleAttributes {
	return RuleAttributes{ref: ref}
}

func (r RuleAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return r.ref.InternalTokens()
}

func (r RuleAttributes) Type() terra.StringValue {
	return terra.ReferenceAsString(r.ref.Append("type"))
}

func (r RuleAttributes) Value() terra.StringValue {
	return terra.ReferenceAsString(r.ref.Append("value"))
}

func (r RuleAttributes) InheritedValue() terra.ListValue[RuleInheritedValueAttributes] {
	return terra.ReferenceAsList[RuleInheritedValueAttributes](r.ref.Append("inherited_value"))
}

func (r RuleAttributes) Rule() terra.ListValue[RuleRuleAttributes] {
	return terra.ReferenceAsList[RuleRuleAttributes](r.ref.Append("rule"))
}

type RuleInheritedValueAttributes struct {
	ref terra.Reference
}

func (iv RuleInheritedValueAttributes) InternalRef() (terra.Reference, error) {
	return iv.ref, nil
}

func (iv RuleInheritedValueAttributes) InternalWithRef(ref terra.Reference) RuleInheritedValueAttributes {
	return RuleInheritedValueAttributes{ref: ref}
}

func (iv RuleInheritedValueAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return iv.ref.InternalTokens()
}

func (iv RuleInheritedValueAttributes) DimensionKey() terra.StringValue {
	return terra.ReferenceAsString(iv.ref.Append("dimension_key"))
}

func (iv RuleInheritedValueAttributes) DimensionName() terra.StringValue {
	return terra.ReferenceAsString(iv.ref.Append("dimension_name"))
}

type RuleRuleAttributes struct {
	ref terra.Reference
}

func (r RuleRuleAttributes) InternalRef() (terra.Reference, error) {
	return r.ref, nil
}

func (r RuleRuleAttributes) InternalWithRef(ref terra.Reference) RuleRuleAttributes {
	return RuleRuleAttributes{ref: ref}
}

func (r RuleRuleAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return r.ref.InternalTokens()
}

func (r RuleRuleAttributes) And() terra.SetValue[RuleRuleAndAttributes] {
	return terra.ReferenceAsSet[RuleRuleAndAttributes](r.ref.Append("and"))
}

func (r RuleRuleAttributes) CostCategory() terra.ListValue[RuleRuleCostCategoryAttributes] {
	return terra.ReferenceAsList[RuleRuleCostCategoryAttributes](r.ref.Append("cost_category"))
}

func (r RuleRuleAttributes) Dimension() terra.ListValue[RuleRuleDimensionAttributes] {
	return terra.ReferenceAsList[RuleRuleDimensionAttributes](r.ref.Append("dimension"))
}

func (r RuleRuleAttributes) Not() terra.ListValue[RuleRuleNotAttributes] {
	return terra.ReferenceAsList[RuleRuleNotAttributes](r.ref.Append("not"))
}

func (r RuleRuleAttributes) Or() terra.SetValue[RuleRuleOrAttributes] {
	return terra.ReferenceAsSet[RuleRuleOrAttributes](r.ref.Append("or"))
}

func (r RuleRuleAttributes) Tags() terra.ListValue[RuleRuleTagsAttributes] {
	return terra.ReferenceAsList[RuleRuleTagsAttributes](r.ref.Append("tags"))
}

type RuleRuleAndAttributes struct {
	ref terra.Reference
}

func (a RuleRuleAndAttributes) InternalRef() (terra.Reference, error) {
	return a.ref, nil
}

func (a RuleRuleAndAttributes) InternalWithRef(ref terra.Reference) RuleRuleAndAttributes {
	return RuleRuleAndAttributes{ref: ref}
}

func (a RuleRuleAndAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return a.ref.InternalTokens()
}

func (a RuleRuleAndAttributes) CostCategory() terra.ListValue[RuleRuleAndCostCategoryAttributes] {
	return terra.ReferenceAsList[RuleRuleAndCostCategoryAttributes](a.ref.Append("cost_category"))
}

func (a RuleRuleAndAttributes) Dimension() terra.ListValue[RuleRuleAndDimensionAttributes] {
	return terra.ReferenceAsList[RuleRuleAndDimensionAttributes](a.ref.Append("dimension"))
}

func (a RuleRuleAndAttributes) Tags() terra.ListValue[RuleRuleAndTagsAttributes] {
	return terra.ReferenceAsList[RuleRuleAndTagsAttributes](a.ref.Append("tags"))
}

type RuleRuleAndCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc RuleRuleAndCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc RuleRuleAndCostCategoryAttributes) InternalWithRef(ref terra.Reference) RuleRuleAndCostCategoryAttributes {
	return RuleRuleAndCostCategoryAttributes{ref: ref}
}

func (cc RuleRuleAndCostCategoryAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cc.ref.InternalTokens()
}

func (cc RuleRuleAndCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc RuleRuleAndCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc RuleRuleAndCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type RuleRuleAndDimensionAttributes struct {
	ref terra.Reference
}

func (d RuleRuleAndDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d RuleRuleAndDimensionAttributes) InternalWithRef(ref terra.Reference) RuleRuleAndDimensionAttributes {
	return RuleRuleAndDimensionAttributes{ref: ref}
}

func (d RuleRuleAndDimensionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return d.ref.InternalTokens()
}

func (d RuleRuleAndDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d RuleRuleAndDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d RuleRuleAndDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type RuleRuleAndTagsAttributes struct {
	ref terra.Reference
}

func (t RuleRuleAndTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t RuleRuleAndTagsAttributes) InternalWithRef(ref terra.Reference) RuleRuleAndTagsAttributes {
	return RuleRuleAndTagsAttributes{ref: ref}
}

func (t RuleRuleAndTagsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return t.ref.InternalTokens()
}

func (t RuleRuleAndTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t RuleRuleAndTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t RuleRuleAndTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type RuleRuleCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc RuleRuleCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc RuleRuleCostCategoryAttributes) InternalWithRef(ref terra.Reference) RuleRuleCostCategoryAttributes {
	return RuleRuleCostCategoryAttributes{ref: ref}
}

func (cc RuleRuleCostCategoryAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cc.ref.InternalTokens()
}

func (cc RuleRuleCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc RuleRuleCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc RuleRuleCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type RuleRuleDimensionAttributes struct {
	ref terra.Reference
}

func (d RuleRuleDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d RuleRuleDimensionAttributes) InternalWithRef(ref terra.Reference) RuleRuleDimensionAttributes {
	return RuleRuleDimensionAttributes{ref: ref}
}

func (d RuleRuleDimensionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return d.ref.InternalTokens()
}

func (d RuleRuleDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d RuleRuleDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d RuleRuleDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type RuleRuleNotAttributes struct {
	ref terra.Reference
}

func (n RuleRuleNotAttributes) InternalRef() (terra.Reference, error) {
	return n.ref, nil
}

func (n RuleRuleNotAttributes) InternalWithRef(ref terra.Reference) RuleRuleNotAttributes {
	return RuleRuleNotAttributes{ref: ref}
}

func (n RuleRuleNotAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return n.ref.InternalTokens()
}

func (n RuleRuleNotAttributes) CostCategory() terra.ListValue[RuleRuleNotCostCategoryAttributes] {
	return terra.ReferenceAsList[RuleRuleNotCostCategoryAttributes](n.ref.Append("cost_category"))
}

func (n RuleRuleNotAttributes) Dimension() terra.ListValue[RuleRuleNotDimensionAttributes] {
	return terra.ReferenceAsList[RuleRuleNotDimensionAttributes](n.ref.Append("dimension"))
}

func (n RuleRuleNotAttributes) Tags() terra.ListValue[RuleRuleNotTagsAttributes] {
	return terra.ReferenceAsList[RuleRuleNotTagsAttributes](n.ref.Append("tags"))
}

type RuleRuleNotCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc RuleRuleNotCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc RuleRuleNotCostCategoryAttributes) InternalWithRef(ref terra.Reference) RuleRuleNotCostCategoryAttributes {
	return RuleRuleNotCostCategoryAttributes{ref: ref}
}

func (cc RuleRuleNotCostCategoryAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cc.ref.InternalTokens()
}

func (cc RuleRuleNotCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc RuleRuleNotCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc RuleRuleNotCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type RuleRuleNotDimensionAttributes struct {
	ref terra.Reference
}

func (d RuleRuleNotDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d RuleRuleNotDimensionAttributes) InternalWithRef(ref terra.Reference) RuleRuleNotDimensionAttributes {
	return RuleRuleNotDimensionAttributes{ref: ref}
}

func (d RuleRuleNotDimensionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return d.ref.InternalTokens()
}

func (d RuleRuleNotDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d RuleRuleNotDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d RuleRuleNotDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type RuleRuleNotTagsAttributes struct {
	ref terra.Reference
}

func (t RuleRuleNotTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t RuleRuleNotTagsAttributes) InternalWithRef(ref terra.Reference) RuleRuleNotTagsAttributes {
	return RuleRuleNotTagsAttributes{ref: ref}
}

func (t RuleRuleNotTagsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return t.ref.InternalTokens()
}

func (t RuleRuleNotTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t RuleRuleNotTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t RuleRuleNotTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type RuleRuleOrAttributes struct {
	ref terra.Reference
}

func (o RuleRuleOrAttributes) InternalRef() (terra.Reference, error) {
	return o.ref, nil
}

func (o RuleRuleOrAttributes) InternalWithRef(ref terra.Reference) RuleRuleOrAttributes {
	return RuleRuleOrAttributes{ref: ref}
}

func (o RuleRuleOrAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return o.ref.InternalTokens()
}

func (o RuleRuleOrAttributes) CostCategory() terra.ListValue[RuleRuleOrCostCategoryAttributes] {
	return terra.ReferenceAsList[RuleRuleOrCostCategoryAttributes](o.ref.Append("cost_category"))
}

func (o RuleRuleOrAttributes) Dimension() terra.ListValue[RuleRuleOrDimensionAttributes] {
	return terra.ReferenceAsList[RuleRuleOrDimensionAttributes](o.ref.Append("dimension"))
}

func (o RuleRuleOrAttributes) Tags() terra.ListValue[RuleRuleOrTagsAttributes] {
	return terra.ReferenceAsList[RuleRuleOrTagsAttributes](o.ref.Append("tags"))
}

type RuleRuleOrCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc RuleRuleOrCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc RuleRuleOrCostCategoryAttributes) InternalWithRef(ref terra.Reference) RuleRuleOrCostCategoryAttributes {
	return RuleRuleOrCostCategoryAttributes{ref: ref}
}

func (cc RuleRuleOrCostCategoryAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cc.ref.InternalTokens()
}

func (cc RuleRuleOrCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc RuleRuleOrCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc RuleRuleOrCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type RuleRuleOrDimensionAttributes struct {
	ref terra.Reference
}

func (d RuleRuleOrDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d RuleRuleOrDimensionAttributes) InternalWithRef(ref terra.Reference) RuleRuleOrDimensionAttributes {
	return RuleRuleOrDimensionAttributes{ref: ref}
}

func (d RuleRuleOrDimensionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return d.ref.InternalTokens()
}

func (d RuleRuleOrDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d RuleRuleOrDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d RuleRuleOrDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type RuleRuleOrTagsAttributes struct {
	ref terra.Reference
}

func (t RuleRuleOrTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t RuleRuleOrTagsAttributes) InternalWithRef(ref terra.Reference) RuleRuleOrTagsAttributes {
	return RuleRuleOrTagsAttributes{ref: ref}
}

func (t RuleRuleOrTagsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return t.ref.InternalTokens()
}

func (t RuleRuleOrTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t RuleRuleOrTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t RuleRuleOrTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type RuleRuleTagsAttributes struct {
	ref terra.Reference
}

func (t RuleRuleTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t RuleRuleTagsAttributes) InternalWithRef(ref terra.Reference) RuleRuleTagsAttributes {
	return RuleRuleTagsAttributes{ref: ref}
}

func (t RuleRuleTagsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return t.ref.InternalTokens()
}

func (t RuleRuleTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t RuleRuleTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t RuleRuleTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type SplitChargeRuleAttributes struct {
	ref terra.Reference
}

func (scr SplitChargeRuleAttributes) InternalRef() (terra.Reference, error) {
	return scr.ref, nil
}

func (scr SplitChargeRuleAttributes) InternalWithRef(ref terra.Reference) SplitChargeRuleAttributes {
	return SplitChargeRuleAttributes{ref: ref}
}

func (scr SplitChargeRuleAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return scr.ref.InternalTokens()
}

func (scr SplitChargeRuleAttributes) Method() terra.StringValue {
	return terra.ReferenceAsString(scr.ref.Append("method"))
}

func (scr SplitChargeRuleAttributes) Source() terra.StringValue {
	return terra.ReferenceAsString(scr.ref.Append("source"))
}

func (scr SplitChargeRuleAttributes) Targets() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](scr.ref.Append("targets"))
}

func (scr SplitChargeRuleAttributes) Parameter() terra.SetValue[SplitChargeRuleParameterAttributes] {
	return terra.ReferenceAsSet[SplitChargeRuleParameterAttributes](scr.ref.Append("parameter"))
}

type SplitChargeRuleParameterAttributes struct {
	ref terra.Reference
}

func (p SplitChargeRuleParameterAttributes) InternalRef() (terra.Reference, error) {
	return p.ref, nil
}

func (p SplitChargeRuleParameterAttributes) InternalWithRef(ref terra.Reference) SplitChargeRuleParameterAttributes {
	return SplitChargeRuleParameterAttributes{ref: ref}
}

func (p SplitChargeRuleParameterAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return p.ref.InternalTokens()
}

func (p SplitChargeRuleParameterAttributes) Type() terra.StringValue {
	return terra.ReferenceAsString(p.ref.Append("type"))
}

func (p SplitChargeRuleParameterAttributes) Values() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](p.ref.Append("values"))
}

type RuleState struct {
	Type           string                    `json:"type"`
	Value          string                    `json:"value"`
	InheritedValue []RuleInheritedValueState `json:"inherited_value"`
	Rule           []RuleRuleState           `json:"rule"`
}

type RuleInheritedValueState struct {
	DimensionKey  string `json:"dimension_key"`
	DimensionName string `json:"dimension_name"`
}

type RuleRuleState struct {
	And          []RuleRuleAndState          `json:"and"`
	CostCategory []RuleRuleCostCategoryState `json:"cost_category"`
	Dimension    []RuleRuleDimensionState    `json:"dimension"`
	Not          []RuleRuleNotState          `json:"not"`
	Or           []RuleRuleOrState           `json:"or"`
	Tags         []RuleRuleTagsState         `json:"tags"`
}

type RuleRuleAndState struct {
	CostCategory []RuleRuleAndCostCategoryState `json:"cost_category"`
	Dimension    []RuleRuleAndDimensionState    `json:"dimension"`
	Tags         []RuleRuleAndTagsState         `json:"tags"`
}

type RuleRuleAndCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleAndDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleAndTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleNotState struct {
	CostCategory []RuleRuleNotCostCategoryState `json:"cost_category"`
	Dimension    []RuleRuleNotDimensionState    `json:"dimension"`
	Tags         []RuleRuleNotTagsState         `json:"tags"`
}

type RuleRuleNotCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleNotDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleNotTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleOrState struct {
	CostCategory []RuleRuleOrCostCategoryState `json:"cost_category"`
	Dimension    []RuleRuleOrDimensionState    `json:"dimension"`
	Tags         []RuleRuleOrTagsState         `json:"tags"`
}

type RuleRuleOrCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleOrDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleOrTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type SplitChargeRuleState struct {
	Method    string                          `json:"method"`
	Source    string                          `json:"source"`
	Targets   []string                        `json:"targets"`
	Parameter []SplitChargeRuleParameterState `json:"parameter"`
}

type SplitChargeRuleParameterState struct {
	Type   string   `json:"type"`
	Values []string `json:"values"`
}
