// CODE GENERATED BY github.com/golingon/lingon. DO NOT EDIT.

package aws_ce_cost_category

import (
	terra "github.com/golingon/lingon/pkg/terra"
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
)

type DataRuleAttributes struct {
	ref terra.Reference
}

func (r DataRuleAttributes) InternalRef() (terra.Reference, error) {
	return r.ref, nil
}

func (r DataRuleAttributes) InternalWithRef(ref terra.Reference) DataRuleAttributes {
	return DataRuleAttributes{ref: ref}
}

func (r DataRuleAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return r.ref.InternalTokens()
}

func (r DataRuleAttributes) Type() terra.StringValue {
	return terra.ReferenceAsString(r.ref.Append("type"))
}

func (r DataRuleAttributes) Value() terra.StringValue {
	return terra.ReferenceAsString(r.ref.Append("value"))
}

func (r DataRuleAttributes) InheritedValue() terra.ListValue[DataRuleInheritedValueAttributes] {
	return terra.ReferenceAsList[DataRuleInheritedValueAttributes](r.ref.Append("inherited_value"))
}

func (r DataRuleAttributes) Rule() terra.ListValue[DataRuleRuleAttributes] {
	return terra.ReferenceAsList[DataRuleRuleAttributes](r.ref.Append("rule"))
}

type DataRuleInheritedValueAttributes struct {
	ref terra.Reference
}

func (iv DataRuleInheritedValueAttributes) InternalRef() (terra.Reference, error) {
	return iv.ref, nil
}

func (iv DataRuleInheritedValueAttributes) InternalWithRef(ref terra.Reference) DataRuleInheritedValueAttributes {
	return DataRuleInheritedValueAttributes{ref: ref}
}

func (iv DataRuleInheritedValueAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return iv.ref.InternalTokens()
}

func (iv DataRuleInheritedValueAttributes) DimensionKey() terra.StringValue {
	return terra.ReferenceAsString(iv.ref.Append("dimension_key"))
}

func (iv DataRuleInheritedValueAttributes) DimensionName() terra.StringValue {
	return terra.ReferenceAsString(iv.ref.Append("dimension_name"))
}

type DataRuleRuleAttributes struct {
	ref terra.Reference
}

func (r DataRuleRuleAttributes) InternalRef() (terra.Reference, error) {
	return r.ref, nil
}

func (r DataRuleRuleAttributes) InternalWithRef(ref terra.Reference) DataRuleRuleAttributes {
	return DataRuleRuleAttributes{ref: ref}
}

func (r DataRuleRuleAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return r.ref.InternalTokens()
}

func (r DataRuleRuleAttributes) And() terra.SetValue[DataRuleRuleAndAttributes] {
	return terra.ReferenceAsSet[DataRuleRuleAndAttributes](r.ref.Append("and"))
}

func (r DataRuleRuleAttributes) CostCategory() terra.ListValue[DataRuleRuleCostCategoryAttributes] {
	return terra.ReferenceAsList[DataRuleRuleCostCategoryAttributes](r.ref.Append("cost_category"))
}

func (r DataRuleRuleAttributes) Dimension() terra.ListValue[DataRuleRuleDimensionAttributes] {
	return terra.ReferenceAsList[DataRuleRuleDimensionAttributes](r.ref.Append("dimension"))
}

func (r DataRuleRuleAttributes) Not() terra.ListValue[DataRuleRuleNotAttributes] {
	return terra.ReferenceAsList[DataRuleRuleNotAttributes](r.ref.Append("not"))
}

func (r DataRuleRuleAttributes) Or() terra.SetValue[DataRuleRuleOrAttributes] {
	return terra.ReferenceAsSet[DataRuleRuleOrAttributes](r.ref.Append("or"))
}

func (r DataRuleRuleAttributes) Tags() terra.ListValue[DataRuleRuleTagsAttributes] {
	return terra.ReferenceAsList[DataRuleRuleTagsAttributes](r.ref.Append("tags"))
}

type DataRuleRuleAndAttributes struct {
	ref terra.Reference
}

func (a DataRuleRuleAndAttributes) InternalRef() (terra.Reference, error) {
	return a.ref, nil
}

func (a DataRuleRuleAndAttributes) InternalWithRef(ref terra.Reference) DataRuleRuleAndAttributes {
	return DataRuleRuleAndAttributes{ref: ref}
}

func (a DataRuleRuleAndAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return a.ref.InternalTokens()
}

func (a DataRuleRuleAndAttributes) CostCategory() terra.ListValue[DataRuleRuleAndCostCategoryAttributes] {
	return terra.ReferenceAsList[DataRuleRuleAndCostCategoryAttributes](a.ref.Append("cost_category"))
}

func (a DataRuleRuleAndAttributes) Dimension() terra.ListValue[DataRuleRuleAndDimensionAttributes] {
	return terra.ReferenceAsList[DataRuleRuleAndDimensionAttributes](a.ref.Append("dimension"))
}

func (a DataRuleRuleAndAttributes) Tags() terra.ListValue[DataRuleRuleAndTagsAttributes] {
	return terra.ReferenceAsList[DataRuleRuleAndTagsAttributes](a.ref.Append("tags"))
}

type DataRuleRuleAndCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc DataRuleRuleAndCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc DataRuleRuleAndCostCategoryAttributes) InternalWithRef(ref terra.Reference) DataRuleRuleAndCostCategoryAttributes {
	return DataRuleRuleAndCostCategoryAttributes{ref: ref}
}

func (cc DataRuleRuleAndCostCategoryAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cc.ref.InternalTokens()
}

func (cc DataRuleRuleAndCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc DataRuleRuleAndCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc DataRuleRuleAndCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type DataRuleRuleAndDimensionAttributes struct {
	ref terra.Reference
}

func (d DataRuleRuleAndDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d DataRuleRuleAndDimensionAttributes) InternalWithRef(ref terra.Reference) DataRuleRuleAndDimensionAttributes {
	return DataRuleRuleAndDimensionAttributes{ref: ref}
}

func (d DataRuleRuleAndDimensionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return d.ref.InternalTokens()
}

func (d DataRuleRuleAndDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d DataRuleRuleAndDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d DataRuleRuleAndDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type DataRuleRuleAndTagsAttributes struct {
	ref terra.Reference
}

func (t DataRuleRuleAndTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t DataRuleRuleAndTagsAttributes) InternalWithRef(ref terra.Reference) DataRuleRuleAndTagsAttributes {
	return DataRuleRuleAndTagsAttributes{ref: ref}
}

func (t DataRuleRuleAndTagsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return t.ref.InternalTokens()
}

func (t DataRuleRuleAndTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t DataRuleRuleAndTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t DataRuleRuleAndTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type DataRuleRuleCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc DataRuleRuleCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc DataRuleRuleCostCategoryAttributes) InternalWithRef(ref terra.Reference) DataRuleRuleCostCategoryAttributes {
	return DataRuleRuleCostCategoryAttributes{ref: ref}
}

func (cc DataRuleRuleCostCategoryAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cc.ref.InternalTokens()
}

func (cc DataRuleRuleCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc DataRuleRuleCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc DataRuleRuleCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type DataRuleRuleDimensionAttributes struct {
	ref terra.Reference
}

func (d DataRuleRuleDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d DataRuleRuleDimensionAttributes) InternalWithRef(ref terra.Reference) DataRuleRuleDimensionAttributes {
	return DataRuleRuleDimensionAttributes{ref: ref}
}

func (d DataRuleRuleDimensionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return d.ref.InternalTokens()
}

func (d DataRuleRuleDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d DataRuleRuleDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d DataRuleRuleDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type DataRuleRuleNotAttributes struct {
	ref terra.Reference
}

func (n DataRuleRuleNotAttributes) InternalRef() (terra.Reference, error) {
	return n.ref, nil
}

func (n DataRuleRuleNotAttributes) InternalWithRef(ref terra.Reference) DataRuleRuleNotAttributes {
	return DataRuleRuleNotAttributes{ref: ref}
}

func (n DataRuleRuleNotAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return n.ref.InternalTokens()
}

func (n DataRuleRuleNotAttributes) CostCategory() terra.ListValue[DataRuleRuleNotCostCategoryAttributes] {
	return terra.ReferenceAsList[DataRuleRuleNotCostCategoryAttributes](n.ref.Append("cost_category"))
}

func (n DataRuleRuleNotAttributes) Dimension() terra.ListValue[DataRuleRuleNotDimensionAttributes] {
	return terra.ReferenceAsList[DataRuleRuleNotDimensionAttributes](n.ref.Append("dimension"))
}

func (n DataRuleRuleNotAttributes) Tags() terra.ListValue[DataRuleRuleNotTagsAttributes] {
	return terra.ReferenceAsList[DataRuleRuleNotTagsAttributes](n.ref.Append("tags"))
}

type DataRuleRuleNotCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc DataRuleRuleNotCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc DataRuleRuleNotCostCategoryAttributes) InternalWithRef(ref terra.Reference) DataRuleRuleNotCostCategoryAttributes {
	return DataRuleRuleNotCostCategoryAttributes{ref: ref}
}

func (cc DataRuleRuleNotCostCategoryAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cc.ref.InternalTokens()
}

func (cc DataRuleRuleNotCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc DataRuleRuleNotCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc DataRuleRuleNotCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type DataRuleRuleNotDimensionAttributes struct {
	ref terra.Reference
}

func (d DataRuleRuleNotDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d DataRuleRuleNotDimensionAttributes) InternalWithRef(ref terra.Reference) DataRuleRuleNotDimensionAttributes {
	return DataRuleRuleNotDimensionAttributes{ref: ref}
}

func (d DataRuleRuleNotDimensionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return d.ref.InternalTokens()
}

func (d DataRuleRuleNotDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d DataRuleRuleNotDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d DataRuleRuleNotDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type DataRuleRuleNotTagsAttributes struct {
	ref terra.Reference
}

func (t DataRuleRuleNotTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t DataRuleRuleNotTagsAttributes) InternalWithRef(ref terra.Reference) DataRuleRuleNotTagsAttributes {
	return DataRuleRuleNotTagsAttributes{ref: ref}
}

func (t DataRuleRuleNotTagsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return t.ref.InternalTokens()
}

func (t DataRuleRuleNotTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t DataRuleRuleNotTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t DataRuleRuleNotTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type DataRuleRuleOrAttributes struct {
	ref terra.Reference
}

func (o DataRuleRuleOrAttributes) InternalRef() (terra.Reference, error) {
	return o.ref, nil
}

func (o DataRuleRuleOrAttributes) InternalWithRef(ref terra.Reference) DataRuleRuleOrAttributes {
	return DataRuleRuleOrAttributes{ref: ref}
}

func (o DataRuleRuleOrAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return o.ref.InternalTokens()
}

func (o DataRuleRuleOrAttributes) CostCategory() terra.ListValue[DataRuleRuleOrCostCategoryAttributes] {
	return terra.ReferenceAsList[DataRuleRuleOrCostCategoryAttributes](o.ref.Append("cost_category"))
}

func (o DataRuleRuleOrAttributes) Dimension() terra.ListValue[DataRuleRuleOrDimensionAttributes] {
	return terra.ReferenceAsList[DataRuleRuleOrDimensionAttributes](o.ref.Append("dimension"))
}

func (o DataRuleRuleOrAttributes) Tags() terra.ListValue[DataRuleRuleOrTagsAttributes] {
	return terra.ReferenceAsList[DataRuleRuleOrTagsAttributes](o.ref.Append("tags"))
}

type DataRuleRuleOrCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc DataRuleRuleOrCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc DataRuleRuleOrCostCategoryAttributes) InternalWithRef(ref terra.Reference) DataRuleRuleOrCostCategoryAttributes {
	return DataRuleRuleOrCostCategoryAttributes{ref: ref}
}

func (cc DataRuleRuleOrCostCategoryAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cc.ref.InternalTokens()
}

func (cc DataRuleRuleOrCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc DataRuleRuleOrCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc DataRuleRuleOrCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type DataRuleRuleOrDimensionAttributes struct {
	ref terra.Reference
}

func (d DataRuleRuleOrDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d DataRuleRuleOrDimensionAttributes) InternalWithRef(ref terra.Reference) DataRuleRuleOrDimensionAttributes {
	return DataRuleRuleOrDimensionAttributes{ref: ref}
}

func (d DataRuleRuleOrDimensionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return d.ref.InternalTokens()
}

func (d DataRuleRuleOrDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d DataRuleRuleOrDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d DataRuleRuleOrDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type DataRuleRuleOrTagsAttributes struct {
	ref terra.Reference
}

func (t DataRuleRuleOrTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t DataRuleRuleOrTagsAttributes) InternalWithRef(ref terra.Reference) DataRuleRuleOrTagsAttributes {
	return DataRuleRuleOrTagsAttributes{ref: ref}
}

func (t DataRuleRuleOrTagsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return t.ref.InternalTokens()
}

func (t DataRuleRuleOrTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t DataRuleRuleOrTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t DataRuleRuleOrTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type DataRuleRuleTagsAttributes struct {
	ref terra.Reference
}

func (t DataRuleRuleTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t DataRuleRuleTagsAttributes) InternalWithRef(ref terra.Reference) DataRuleRuleTagsAttributes {
	return DataRuleRuleTagsAttributes{ref: ref}
}

func (t DataRuleRuleTagsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return t.ref.InternalTokens()
}

func (t DataRuleRuleTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t DataRuleRuleTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t DataRuleRuleTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type DataSplitChargeRuleAttributes struct {
	ref terra.Reference
}

func (scr DataSplitChargeRuleAttributes) InternalRef() (terra.Reference, error) {
	return scr.ref, nil
}

func (scr DataSplitChargeRuleAttributes) InternalWithRef(ref terra.Reference) DataSplitChargeRuleAttributes {
	return DataSplitChargeRuleAttributes{ref: ref}
}

func (scr DataSplitChargeRuleAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return scr.ref.InternalTokens()
}

func (scr DataSplitChargeRuleAttributes) Method() terra.StringValue {
	return terra.ReferenceAsString(scr.ref.Append("method"))
}

func (scr DataSplitChargeRuleAttributes) Source() terra.StringValue {
	return terra.ReferenceAsString(scr.ref.Append("source"))
}

func (scr DataSplitChargeRuleAttributes) Targets() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](scr.ref.Append("targets"))
}

func (scr DataSplitChargeRuleAttributes) Parameter() terra.SetValue[DataSplitChargeRuleParameterAttributes] {
	return terra.ReferenceAsSet[DataSplitChargeRuleParameterAttributes](scr.ref.Append("parameter"))
}

type DataSplitChargeRuleParameterAttributes struct {
	ref terra.Reference
}

func (p DataSplitChargeRuleParameterAttributes) InternalRef() (terra.Reference, error) {
	return p.ref, nil
}

func (p DataSplitChargeRuleParameterAttributes) InternalWithRef(ref terra.Reference) DataSplitChargeRuleParameterAttributes {
	return DataSplitChargeRuleParameterAttributes{ref: ref}
}

func (p DataSplitChargeRuleParameterAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return p.ref.InternalTokens()
}

func (p DataSplitChargeRuleParameterAttributes) Type() terra.StringValue {
	return terra.ReferenceAsString(p.ref.Append("type"))
}

func (p DataSplitChargeRuleParameterAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](p.ref.Append("values"))
}

type DataRuleState struct {
	Type           string                        `json:"type"`
	Value          string                        `json:"value"`
	InheritedValue []DataRuleInheritedValueState `json:"inherited_value"`
	Rule           []DataRuleRuleState           `json:"rule"`
}

type DataRuleInheritedValueState struct {
	DimensionKey  string `json:"dimension_key"`
	DimensionName string `json:"dimension_name"`
}

type DataRuleRuleState struct {
	And          []DataRuleRuleAndState          `json:"and"`
	CostCategory []DataRuleRuleCostCategoryState `json:"cost_category"`
	Dimension    []DataRuleRuleDimensionState    `json:"dimension"`
	Not          []DataRuleRuleNotState          `json:"not"`
	Or           []DataRuleRuleOrState           `json:"or"`
	Tags         []DataRuleRuleTagsState         `json:"tags"`
}

type DataRuleRuleAndState struct {
	CostCategory []DataRuleRuleAndCostCategoryState `json:"cost_category"`
	Dimension    []DataRuleRuleAndDimensionState    `json:"dimension"`
	Tags         []DataRuleRuleAndTagsState         `json:"tags"`
}

type DataRuleRuleAndCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleAndDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleAndTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleNotState struct {
	CostCategory []DataRuleRuleNotCostCategoryState `json:"cost_category"`
	Dimension    []DataRuleRuleNotDimensionState    `json:"dimension"`
	Tags         []DataRuleRuleNotTagsState         `json:"tags"`
}

type DataRuleRuleNotCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleNotDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleNotTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleOrState struct {
	CostCategory []DataRuleRuleOrCostCategoryState `json:"cost_category"`
	Dimension    []DataRuleRuleOrDimensionState    `json:"dimension"`
	Tags         []DataRuleRuleOrTagsState         `json:"tags"`
}

type DataRuleRuleOrCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleOrDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleOrTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataSplitChargeRuleState struct {
	Method    string                              `json:"method"`
	Source    string                              `json:"source"`
	Targets   []string                            `json:"targets"`
	Parameter []DataSplitChargeRuleParameterState `json:"parameter"`
}

type DataSplitChargeRuleParameterState struct {
	Type   string   `json:"type"`
	Values []string `json:"values"`
}
