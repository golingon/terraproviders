// CODE GENERATED BY github.com/golingon/lingon. DO NOT EDIT.

package aws_vpclattice_listener_rule

import (
	terra "github.com/golingon/lingon/pkg/terra"
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
)

type Action struct {
	// ActionFixedResponse: optional
	FixedResponse *ActionFixedResponse `hcl:"fixed_response,block"`
	// ActionForward: optional
	Forward *ActionForward `hcl:"forward,block"`
}

type ActionFixedResponse struct {
	// StatusCode: number, required
	StatusCode terra.NumberValue `hcl:"status_code,attr" validate:"required"`
}

type ActionForward struct {
	// ActionForwardTargetGroups: min=1
	TargetGroups []ActionForwardTargetGroups `hcl:"target_groups,block" validate:"min=1"`
}

type ActionForwardTargetGroups struct {
	// TargetGroupIdentifier: string, required
	TargetGroupIdentifier terra.StringValue `hcl:"target_group_identifier,attr" validate:"required"`
	// Weight: number, optional
	Weight terra.NumberValue `hcl:"weight,attr"`
}

type Match struct {
	// MatchHttpMatch: optional
	HttpMatch *MatchHttpMatch `hcl:"http_match,block"`
}

type MatchHttpMatch struct {
	// Method: string, optional
	Method terra.StringValue `hcl:"method,attr"`
	// MatchHttpMatchHeaderMatches: min=0,max=5
	HeaderMatches []MatchHttpMatchHeaderMatches `hcl:"header_matches,block" validate:"min=0,max=5"`
	// MatchHttpMatchPathMatch: optional
	PathMatch *MatchHttpMatchPathMatch `hcl:"path_match,block"`
}

type MatchHttpMatchHeaderMatches struct {
	// CaseSensitive: bool, optional
	CaseSensitive terra.BoolValue `hcl:"case_sensitive,attr"`
	// Name: string, required
	Name terra.StringValue `hcl:"name,attr" validate:"required"`
	// MatchHttpMatchHeaderMatchesMatch: required
	Match *MatchHttpMatchHeaderMatchesMatch `hcl:"match,block" validate:"required"`
}

type MatchHttpMatchHeaderMatchesMatch struct {
	// Contains: string, optional
	Contains terra.StringValue `hcl:"contains,attr"`
	// Exact: string, optional
	Exact terra.StringValue `hcl:"exact,attr"`
	// Prefix: string, optional
	Prefix terra.StringValue `hcl:"prefix,attr"`
}

type MatchHttpMatchPathMatch struct {
	// CaseSensitive: bool, optional
	CaseSensitive terra.BoolValue `hcl:"case_sensitive,attr"`
	// MatchHttpMatchPathMatchMatch: required
	Match *MatchHttpMatchPathMatchMatch `hcl:"match,block" validate:"required"`
}

type MatchHttpMatchPathMatchMatch struct {
	// Exact: string, optional
	Exact terra.StringValue `hcl:"exact,attr"`
	// Prefix: string, optional
	Prefix terra.StringValue `hcl:"prefix,attr"`
}

type Timeouts struct {
	// Create: string, optional
	Create terra.StringValue `hcl:"create,attr"`
	// Delete: string, optional
	Delete terra.StringValue `hcl:"delete,attr"`
	// Update: string, optional
	Update terra.StringValue `hcl:"update,attr"`
}

type ActionAttributes struct {
	ref terra.Reference
}

func (a ActionAttributes) InternalRef() (terra.Reference, error) {
	return a.ref, nil
}

func (a ActionAttributes) InternalWithRef(ref terra.Reference) ActionAttributes {
	return ActionAttributes{ref: ref}
}

func (a ActionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return a.ref.InternalTokens()
}

func (a ActionAttributes) FixedResponse() terra.ListValue[ActionFixedResponseAttributes] {
	return terra.ReferenceAsList[ActionFixedResponseAttributes](a.ref.Append("fixed_response"))
}

func (a ActionAttributes) Forward() terra.ListValue[ActionForwardAttributes] {
	return terra.ReferenceAsList[ActionForwardAttributes](a.ref.Append("forward"))
}

type ActionFixedResponseAttributes struct {
	ref terra.Reference
}

func (fr ActionFixedResponseAttributes) InternalRef() (terra.Reference, error) {
	return fr.ref, nil
}

func (fr ActionFixedResponseAttributes) InternalWithRef(ref terra.Reference) ActionFixedResponseAttributes {
	return ActionFixedResponseAttributes{ref: ref}
}

func (fr ActionFixedResponseAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return fr.ref.InternalTokens()
}

func (fr ActionFixedResponseAttributes) StatusCode() terra.NumberValue {
	return terra.ReferenceAsNumber(fr.ref.Append("status_code"))
}

type ActionForwardAttributes struct {
	ref terra.Reference
}

func (f ActionForwardAttributes) InternalRef() (terra.Reference, error) {
	return f.ref, nil
}

func (f ActionForwardAttributes) InternalWithRef(ref terra.Reference) ActionForwardAttributes {
	return ActionForwardAttributes{ref: ref}
}

func (f ActionForwardAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return f.ref.InternalTokens()
}

func (f ActionForwardAttributes) TargetGroups() terra.ListValue[ActionForwardTargetGroupsAttributes] {
	return terra.ReferenceAsList[ActionForwardTargetGroupsAttributes](f.ref.Append("target_groups"))
}

type ActionForwardTargetGroupsAttributes struct {
	ref terra.Reference
}

func (tg ActionForwardTargetGroupsAttributes) InternalRef() (terra.Reference, error) {
	return tg.ref, nil
}

func (tg ActionForwardTargetGroupsAttributes) InternalWithRef(ref terra.Reference) ActionForwardTargetGroupsAttributes {
	return ActionForwardTargetGroupsAttributes{ref: ref}
}

func (tg ActionForwardTargetGroupsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return tg.ref.InternalTokens()
}

func (tg ActionForwardTargetGroupsAttributes) TargetGroupIdentifier() terra.StringValue {
	return terra.ReferenceAsString(tg.ref.Append("target_group_identifier"))
}

func (tg ActionForwardTargetGroupsAttributes) Weight() terra.NumberValue {
	return terra.ReferenceAsNumber(tg.ref.Append("weight"))
}

type MatchAttributes struct {
	ref terra.Reference
}

func (m MatchAttributes) InternalRef() (terra.Reference, error) {
	return m.ref, nil
}

func (m MatchAttributes) InternalWithRef(ref terra.Reference) MatchAttributes {
	return MatchAttributes{ref: ref}
}

func (m MatchAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return m.ref.InternalTokens()
}

func (m MatchAttributes) HttpMatch() terra.ListValue[MatchHttpMatchAttributes] {
	return terra.ReferenceAsList[MatchHttpMatchAttributes](m.ref.Append("http_match"))
}

type MatchHttpMatchAttributes struct {
	ref terra.Reference
}

func (hm MatchHttpMatchAttributes) InternalRef() (terra.Reference, error) {
	return hm.ref, nil
}

func (hm MatchHttpMatchAttributes) InternalWithRef(ref terra.Reference) MatchHttpMatchAttributes {
	return MatchHttpMatchAttributes{ref: ref}
}

func (hm MatchHttpMatchAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return hm.ref.InternalTokens()
}

func (hm MatchHttpMatchAttributes) Method() terra.StringValue {
	return terra.ReferenceAsString(hm.ref.Append("method"))
}

func (hm MatchHttpMatchAttributes) HeaderMatches() terra.ListValue[MatchHttpMatchHeaderMatchesAttributes] {
	return terra.ReferenceAsList[MatchHttpMatchHeaderMatchesAttributes](hm.ref.Append("header_matches"))
}

func (hm MatchHttpMatchAttributes) PathMatch() terra.ListValue[MatchHttpMatchPathMatchAttributes] {
	return terra.ReferenceAsList[MatchHttpMatchPathMatchAttributes](hm.ref.Append("path_match"))
}

type MatchHttpMatchHeaderMatchesAttributes struct {
	ref terra.Reference
}

func (hm MatchHttpMatchHeaderMatchesAttributes) InternalRef() (terra.Reference, error) {
	return hm.ref, nil
}

func (hm MatchHttpMatchHeaderMatchesAttributes) InternalWithRef(ref terra.Reference) MatchHttpMatchHeaderMatchesAttributes {
	return MatchHttpMatchHeaderMatchesAttributes{ref: ref}
}

func (hm MatchHttpMatchHeaderMatchesAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return hm.ref.InternalTokens()
}

func (hm MatchHttpMatchHeaderMatchesAttributes) CaseSensitive() terra.BoolValue {
	return terra.ReferenceAsBool(hm.ref.Append("case_sensitive"))
}

func (hm MatchHttpMatchHeaderMatchesAttributes) Name() terra.StringValue {
	return terra.ReferenceAsString(hm.ref.Append("name"))
}

func (hm MatchHttpMatchHeaderMatchesAttributes) Match() terra.ListValue[MatchHttpMatchHeaderMatchesMatchAttributes] {
	return terra.ReferenceAsList[MatchHttpMatchHeaderMatchesMatchAttributes](hm.ref.Append("match"))
}

type MatchHttpMatchHeaderMatchesMatchAttributes struct {
	ref terra.Reference
}

func (m MatchHttpMatchHeaderMatchesMatchAttributes) InternalRef() (terra.Reference, error) {
	return m.ref, nil
}

func (m MatchHttpMatchHeaderMatchesMatchAttributes) InternalWithRef(ref terra.Reference) MatchHttpMatchHeaderMatchesMatchAttributes {
	return MatchHttpMatchHeaderMatchesMatchAttributes{ref: ref}
}

func (m MatchHttpMatchHeaderMatchesMatchAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return m.ref.InternalTokens()
}

func (m MatchHttpMatchHeaderMatchesMatchAttributes) Contains() terra.StringValue {
	return terra.ReferenceAsString(m.ref.Append("contains"))
}

func (m MatchHttpMatchHeaderMatchesMatchAttributes) Exact() terra.StringValue {
	return terra.ReferenceAsString(m.ref.Append("exact"))
}

func (m MatchHttpMatchHeaderMatchesMatchAttributes) Prefix() terra.StringValue {
	return terra.ReferenceAsString(m.ref.Append("prefix"))
}

type MatchHttpMatchPathMatchAttributes struct {
	ref terra.Reference
}

func (pm MatchHttpMatchPathMatchAttributes) InternalRef() (terra.Reference, error) {
	return pm.ref, nil
}

func (pm MatchHttpMatchPathMatchAttributes) InternalWithRef(ref terra.Reference) MatchHttpMatchPathMatchAttributes {
	return MatchHttpMatchPathMatchAttributes{ref: ref}
}

func (pm MatchHttpMatchPathMatchAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return pm.ref.InternalTokens()
}

func (pm MatchHttpMatchPathMatchAttributes) CaseSensitive() terra.BoolValue {
	return terra.ReferenceAsBool(pm.ref.Append("case_sensitive"))
}

func (pm MatchHttpMatchPathMatchAttributes) Match() terra.ListValue[MatchHttpMatchPathMatchMatchAttributes] {
	return terra.ReferenceAsList[MatchHttpMatchPathMatchMatchAttributes](pm.ref.Append("match"))
}

type MatchHttpMatchPathMatchMatchAttributes struct {
	ref terra.Reference
}

func (m MatchHttpMatchPathMatchMatchAttributes) InternalRef() (terra.Reference, error) {
	return m.ref, nil
}

func (m MatchHttpMatchPathMatchMatchAttributes) InternalWithRef(ref terra.Reference) MatchHttpMatchPathMatchMatchAttributes {
	return MatchHttpMatchPathMatchMatchAttributes{ref: ref}
}

func (m MatchHttpMatchPathMatchMatchAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return m.ref.InternalTokens()
}

func (m MatchHttpMatchPathMatchMatchAttributes) Exact() terra.StringValue {
	return terra.ReferenceAsString(m.ref.Append("exact"))
}

func (m MatchHttpMatchPathMatchMatchAttributes) Prefix() terra.StringValue {
	return terra.ReferenceAsString(m.ref.Append("prefix"))
}

type TimeoutsAttributes struct {
	ref terra.Reference
}

func (t TimeoutsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t TimeoutsAttributes) InternalWithRef(ref terra.Reference) TimeoutsAttributes {
	return TimeoutsAttributes{ref: ref}
}

func (t TimeoutsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return t.ref.InternalTokens()
}

func (t TimeoutsAttributes) Create() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("create"))
}

func (t TimeoutsAttributes) Delete() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("delete"))
}

func (t TimeoutsAttributes) Update() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("update"))
}

type ActionState struct {
	FixedResponse []ActionFixedResponseState `json:"fixed_response"`
	Forward       []ActionForwardState       `json:"forward"`
}

type ActionFixedResponseState struct {
	StatusCode float64 `json:"status_code"`
}

type ActionForwardState struct {
	TargetGroups []ActionForwardTargetGroupsState `json:"target_groups"`
}

type ActionForwardTargetGroupsState struct {
	TargetGroupIdentifier string  `json:"target_group_identifier"`
	Weight                float64 `json:"weight"`
}

type MatchState struct {
	HttpMatch []MatchHttpMatchState `json:"http_match"`
}

type MatchHttpMatchState struct {
	Method        string                             `json:"method"`
	HeaderMatches []MatchHttpMatchHeaderMatchesState `json:"header_matches"`
	PathMatch     []MatchHttpMatchPathMatchState     `json:"path_match"`
}

type MatchHttpMatchHeaderMatchesState struct {
	CaseSensitive bool                                    `json:"case_sensitive"`
	Name          string                                  `json:"name"`
	Match         []MatchHttpMatchHeaderMatchesMatchState `json:"match"`
}

type MatchHttpMatchHeaderMatchesMatchState struct {
	Contains string `json:"contains"`
	Exact    string `json:"exact"`
	Prefix   string `json:"prefix"`
}

type MatchHttpMatchPathMatchState struct {
	CaseSensitive bool                                `json:"case_sensitive"`
	Match         []MatchHttpMatchPathMatchMatchState `json:"match"`
}

type MatchHttpMatchPathMatchMatchState struct {
	Exact  string `json:"exact"`
	Prefix string `json:"prefix"`
}

type TimeoutsState struct {
	Create string `json:"create"`
	Delete string `json:"delete"`
	Update string `json:"update"`
}
