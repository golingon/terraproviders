// CODE GENERATED BY github.com/golingon/lingon. DO NOT EDIT.

package aws_customerprofiles_domain

import (
	terra "github.com/golingon/lingon/pkg/terra"
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
)

type Matching struct {
	// Enabled: bool, required
	Enabled terra.BoolValue `hcl:"enabled,attr" validate:"required"`
	// MatchingAutoMerging: optional
	AutoMerging *MatchingAutoMerging `hcl:"auto_merging,block"`
	// MatchingExportingConfig: optional
	ExportingConfig *MatchingExportingConfig `hcl:"exporting_config,block"`
	// MatchingJobSchedule: optional
	JobSchedule *MatchingJobSchedule `hcl:"job_schedule,block"`
}

type MatchingAutoMerging struct {
	// Enabled: bool, required
	Enabled terra.BoolValue `hcl:"enabled,attr" validate:"required"`
	// MinAllowedConfidenceScoreForMerging: number, optional
	MinAllowedConfidenceScoreForMerging terra.NumberValue `hcl:"min_allowed_confidence_score_for_merging,attr"`
	// MatchingAutoMergingConflictResolution: optional
	ConflictResolution *MatchingAutoMergingConflictResolution `hcl:"conflict_resolution,block"`
	// MatchingAutoMergingConsolidation: optional
	Consolidation *MatchingAutoMergingConsolidation `hcl:"consolidation,block"`
}

type MatchingAutoMergingConflictResolution struct {
	// ConflictResolvingModel: string, required
	ConflictResolvingModel terra.StringValue `hcl:"conflict_resolving_model,attr" validate:"required"`
	// SourceName: string, optional
	SourceName terra.StringValue `hcl:"source_name,attr"`
}

type MatchingAutoMergingConsolidation struct {
	// MatchingAttributesList: list of list of string, required
	MatchingAttributesList terra.ListValue[terra.ListValue[terra.StringValue]] `hcl:"matching_attributes_list,attr" validate:"required"`
}

type MatchingExportingConfig struct {
	// MatchingExportingConfigS3Exporting: optional
	S3Exporting *MatchingExportingConfigS3Exporting `hcl:"s3_exporting,block"`
}

type MatchingExportingConfigS3Exporting struct {
	// S3BucketName: string, required
	S3BucketName terra.StringValue `hcl:"s3_bucket_name,attr" validate:"required"`
	// S3KeyName: string, optional
	S3KeyName terra.StringValue `hcl:"s3_key_name,attr"`
}

type MatchingJobSchedule struct {
	// DayOfTheWeek: string, required
	DayOfTheWeek terra.StringValue `hcl:"day_of_the_week,attr" validate:"required"`
	// Time: string, required
	Time terra.StringValue `hcl:"time,attr" validate:"required"`
}

type RuleBasedMatching struct {
	// Enabled: bool, required
	Enabled terra.BoolValue `hcl:"enabled,attr" validate:"required"`
	// MaxAllowedRuleLevelForMatching: number, optional
	MaxAllowedRuleLevelForMatching terra.NumberValue `hcl:"max_allowed_rule_level_for_matching,attr"`
	// MaxAllowedRuleLevelForMerging: number, optional
	MaxAllowedRuleLevelForMerging terra.NumberValue `hcl:"max_allowed_rule_level_for_merging,attr"`
	// Status: string, optional
	Status terra.StringValue `hcl:"status,attr"`
	// RuleBasedMatchingAttributeTypesSelector: optional
	AttributeTypesSelector *RuleBasedMatchingAttributeTypesSelector `hcl:"attribute_types_selector,block"`
	// RuleBasedMatchingConflictResolution: optional
	ConflictResolution *RuleBasedMatchingConflictResolution `hcl:"conflict_resolution,block"`
	// RuleBasedMatchingExportingConfig: optional
	ExportingConfig *RuleBasedMatchingExportingConfig `hcl:"exporting_config,block"`
	// RuleBasedMatchingMatchingRules: min=0
	MatchingRules []RuleBasedMatchingMatchingRules `hcl:"matching_rules,block" validate:"min=0"`
}

type RuleBasedMatchingAttributeTypesSelector struct {
	// Address: list of string, optional
	Address terra.ListValue[terra.StringValue] `hcl:"address,attr"`
	// AttributeMatchingModel: string, required
	AttributeMatchingModel terra.StringValue `hcl:"attribute_matching_model,attr" validate:"required"`
	// EmailAddress: list of string, optional
	EmailAddress terra.ListValue[terra.StringValue] `hcl:"email_address,attr"`
	// PhoneNumber: list of string, optional
	PhoneNumber terra.ListValue[terra.StringValue] `hcl:"phone_number,attr"`
}

type RuleBasedMatchingConflictResolution struct {
	// ConflictResolvingModel: string, required
	ConflictResolvingModel terra.StringValue `hcl:"conflict_resolving_model,attr" validate:"required"`
	// SourceName: string, optional
	SourceName terra.StringValue `hcl:"source_name,attr"`
}

type RuleBasedMatchingExportingConfig struct {
	// RuleBasedMatchingExportingConfigS3Exporting: optional
	S3Exporting *RuleBasedMatchingExportingConfigS3Exporting `hcl:"s3_exporting,block"`
}

type RuleBasedMatchingExportingConfigS3Exporting struct {
	// S3BucketName: string, required
	S3BucketName terra.StringValue `hcl:"s3_bucket_name,attr" validate:"required"`
	// S3KeyName: string, optional
	S3KeyName terra.StringValue `hcl:"s3_key_name,attr"`
}

type RuleBasedMatchingMatchingRules struct {
	// Rule: list of string, required
	Rule terra.ListValue[terra.StringValue] `hcl:"rule,attr" validate:"required"`
}

type MatchingAttributes struct {
	ref terra.Reference
}

func (m MatchingAttributes) InternalRef() (terra.Reference, error) {
	return m.ref, nil
}

func (m MatchingAttributes) InternalWithRef(ref terra.Reference) MatchingAttributes {
	return MatchingAttributes{ref: ref}
}

func (m MatchingAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return m.ref.InternalTokens()
}

func (m MatchingAttributes) Enabled() terra.BoolValue {
	return terra.ReferenceAsBool(m.ref.Append("enabled"))
}

func (m MatchingAttributes) AutoMerging() terra.ListValue[MatchingAutoMergingAttributes] {
	return terra.ReferenceAsList[MatchingAutoMergingAttributes](m.ref.Append("auto_merging"))
}

func (m MatchingAttributes) ExportingConfig() terra.ListValue[MatchingExportingConfigAttributes] {
	return terra.ReferenceAsList[MatchingExportingConfigAttributes](m.ref.Append("exporting_config"))
}

func (m MatchingAttributes) JobSchedule() terra.ListValue[MatchingJobScheduleAttributes] {
	return terra.ReferenceAsList[MatchingJobScheduleAttributes](m.ref.Append("job_schedule"))
}

type MatchingAutoMergingAttributes struct {
	ref terra.Reference
}

func (am MatchingAutoMergingAttributes) InternalRef() (terra.Reference, error) {
	return am.ref, nil
}

func (am MatchingAutoMergingAttributes) InternalWithRef(ref terra.Reference) MatchingAutoMergingAttributes {
	return MatchingAutoMergingAttributes{ref: ref}
}

func (am MatchingAutoMergingAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return am.ref.InternalTokens()
}

func (am MatchingAutoMergingAttributes) Enabled() terra.BoolValue {
	return terra.ReferenceAsBool(am.ref.Append("enabled"))
}

func (am MatchingAutoMergingAttributes) MinAllowedConfidenceScoreForMerging() terra.NumberValue {
	return terra.ReferenceAsNumber(am.ref.Append("min_allowed_confidence_score_for_merging"))
}

func (am MatchingAutoMergingAttributes) ConflictResolution() terra.ListValue[MatchingAutoMergingConflictResolutionAttributes] {
	return terra.ReferenceAsList[MatchingAutoMergingConflictResolutionAttributes](am.ref.Append("conflict_resolution"))
}

func (am MatchingAutoMergingAttributes) Consolidation() terra.ListValue[MatchingAutoMergingConsolidationAttributes] {
	return terra.ReferenceAsList[MatchingAutoMergingConsolidationAttributes](am.ref.Append("consolidation"))
}

type MatchingAutoMergingConflictResolutionAttributes struct {
	ref terra.Reference
}

func (cr MatchingAutoMergingConflictResolutionAttributes) InternalRef() (terra.Reference, error) {
	return cr.ref, nil
}

func (cr MatchingAutoMergingConflictResolutionAttributes) InternalWithRef(ref terra.Reference) MatchingAutoMergingConflictResolutionAttributes {
	return MatchingAutoMergingConflictResolutionAttributes{ref: ref}
}

func (cr MatchingAutoMergingConflictResolutionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cr.ref.InternalTokens()
}

func (cr MatchingAutoMergingConflictResolutionAttributes) ConflictResolvingModel() terra.StringValue {
	return terra.ReferenceAsString(cr.ref.Append("conflict_resolving_model"))
}

func (cr MatchingAutoMergingConflictResolutionAttributes) SourceName() terra.StringValue {
	return terra.ReferenceAsString(cr.ref.Append("source_name"))
}

type MatchingAutoMergingConsolidationAttributes struct {
	ref terra.Reference
}

func (c MatchingAutoMergingConsolidationAttributes) InternalRef() (terra.Reference, error) {
	return c.ref, nil
}

func (c MatchingAutoMergingConsolidationAttributes) InternalWithRef(ref terra.Reference) MatchingAutoMergingConsolidationAttributes {
	return MatchingAutoMergingConsolidationAttributes{ref: ref}
}

func (c MatchingAutoMergingConsolidationAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return c.ref.InternalTokens()
}

func (c MatchingAutoMergingConsolidationAttributes) MatchingAttributesList() terra.ListValue[terra.ListValue[terra.StringValue]] {
	return terra.ReferenceAsList[terra.ListValue[terra.StringValue]](c.ref.Append("matching_attributes_list"))
}

type MatchingExportingConfigAttributes struct {
	ref terra.Reference
}

func (ec MatchingExportingConfigAttributes) InternalRef() (terra.Reference, error) {
	return ec.ref, nil
}

func (ec MatchingExportingConfigAttributes) InternalWithRef(ref terra.Reference) MatchingExportingConfigAttributes {
	return MatchingExportingConfigAttributes{ref: ref}
}

func (ec MatchingExportingConfigAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return ec.ref.InternalTokens()
}

func (ec MatchingExportingConfigAttributes) S3Exporting() terra.ListValue[MatchingExportingConfigS3ExportingAttributes] {
	return terra.ReferenceAsList[MatchingExportingConfigS3ExportingAttributes](ec.ref.Append("s3_exporting"))
}

type MatchingExportingConfigS3ExportingAttributes struct {
	ref terra.Reference
}

func (se MatchingExportingConfigS3ExportingAttributes) InternalRef() (terra.Reference, error) {
	return se.ref, nil
}

func (se MatchingExportingConfigS3ExportingAttributes) InternalWithRef(ref terra.Reference) MatchingExportingConfigS3ExportingAttributes {
	return MatchingExportingConfigS3ExportingAttributes{ref: ref}
}

func (se MatchingExportingConfigS3ExportingAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return se.ref.InternalTokens()
}

func (se MatchingExportingConfigS3ExportingAttributes) S3BucketName() terra.StringValue {
	return terra.ReferenceAsString(se.ref.Append("s3_bucket_name"))
}

func (se MatchingExportingConfigS3ExportingAttributes) S3KeyName() terra.StringValue {
	return terra.ReferenceAsString(se.ref.Append("s3_key_name"))
}

type MatchingJobScheduleAttributes struct {
	ref terra.Reference
}

func (js MatchingJobScheduleAttributes) InternalRef() (terra.Reference, error) {
	return js.ref, nil
}

func (js MatchingJobScheduleAttributes) InternalWithRef(ref terra.Reference) MatchingJobScheduleAttributes {
	return MatchingJobScheduleAttributes{ref: ref}
}

func (js MatchingJobScheduleAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return js.ref.InternalTokens()
}

func (js MatchingJobScheduleAttributes) DayOfTheWeek() terra.StringValue {
	return terra.ReferenceAsString(js.ref.Append("day_of_the_week"))
}

func (js MatchingJobScheduleAttributes) Time() terra.StringValue {
	return terra.ReferenceAsString(js.ref.Append("time"))
}

type RuleBasedMatchingAttributes struct {
	ref terra.Reference
}

func (rbm RuleBasedMatchingAttributes) InternalRef() (terra.Reference, error) {
	return rbm.ref, nil
}

func (rbm RuleBasedMatchingAttributes) InternalWithRef(ref terra.Reference) RuleBasedMatchingAttributes {
	return RuleBasedMatchingAttributes{ref: ref}
}

func (rbm RuleBasedMatchingAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return rbm.ref.InternalTokens()
}

func (rbm RuleBasedMatchingAttributes) Enabled() terra.BoolValue {
	return terra.ReferenceAsBool(rbm.ref.Append("enabled"))
}

func (rbm RuleBasedMatchingAttributes) MaxAllowedRuleLevelForMatching() terra.NumberValue {
	return terra.ReferenceAsNumber(rbm.ref.Append("max_allowed_rule_level_for_matching"))
}

func (rbm RuleBasedMatchingAttributes) MaxAllowedRuleLevelForMerging() terra.NumberValue {
	return terra.ReferenceAsNumber(rbm.ref.Append("max_allowed_rule_level_for_merging"))
}

func (rbm RuleBasedMatchingAttributes) Status() terra.StringValue {
	return terra.ReferenceAsString(rbm.ref.Append("status"))
}

func (rbm RuleBasedMatchingAttributes) AttributeTypesSelector() terra.ListValue[RuleBasedMatchingAttributeTypesSelectorAttributes] {
	return terra.ReferenceAsList[RuleBasedMatchingAttributeTypesSelectorAttributes](rbm.ref.Append("attribute_types_selector"))
}

func (rbm RuleBasedMatchingAttributes) ConflictResolution() terra.ListValue[RuleBasedMatchingConflictResolutionAttributes] {
	return terra.ReferenceAsList[RuleBasedMatchingConflictResolutionAttributes](rbm.ref.Append("conflict_resolution"))
}

func (rbm RuleBasedMatchingAttributes) ExportingConfig() terra.ListValue[RuleBasedMatchingExportingConfigAttributes] {
	return terra.ReferenceAsList[RuleBasedMatchingExportingConfigAttributes](rbm.ref.Append("exporting_config"))
}

func (rbm RuleBasedMatchingAttributes) MatchingRules() terra.SetValue[RuleBasedMatchingMatchingRulesAttributes] {
	return terra.ReferenceAsSet[RuleBasedMatchingMatchingRulesAttributes](rbm.ref.Append("matching_rules"))
}

type RuleBasedMatchingAttributeTypesSelectorAttributes struct {
	ref terra.Reference
}

func (ats RuleBasedMatchingAttributeTypesSelectorAttributes) InternalRef() (terra.Reference, error) {
	return ats.ref, nil
}

func (ats RuleBasedMatchingAttributeTypesSelectorAttributes) InternalWithRef(ref terra.Reference) RuleBasedMatchingAttributeTypesSelectorAttributes {
	return RuleBasedMatchingAttributeTypesSelectorAttributes{ref: ref}
}

func (ats RuleBasedMatchingAttributeTypesSelectorAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return ats.ref.InternalTokens()
}

func (ats RuleBasedMatchingAttributeTypesSelectorAttributes) Address() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](ats.ref.Append("address"))
}

func (ats RuleBasedMatchingAttributeTypesSelectorAttributes) AttributeMatchingModel() terra.StringValue {
	return terra.ReferenceAsString(ats.ref.Append("attribute_matching_model"))
}

func (ats RuleBasedMatchingAttributeTypesSelectorAttributes) EmailAddress() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](ats.ref.Append("email_address"))
}

func (ats RuleBasedMatchingAttributeTypesSelectorAttributes) PhoneNumber() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](ats.ref.Append("phone_number"))
}

type RuleBasedMatchingConflictResolutionAttributes struct {
	ref terra.Reference
}

func (cr RuleBasedMatchingConflictResolutionAttributes) InternalRef() (terra.Reference, error) {
	return cr.ref, nil
}

func (cr RuleBasedMatchingConflictResolutionAttributes) InternalWithRef(ref terra.Reference) RuleBasedMatchingConflictResolutionAttributes {
	return RuleBasedMatchingConflictResolutionAttributes{ref: ref}
}

func (cr RuleBasedMatchingConflictResolutionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cr.ref.InternalTokens()
}

func (cr RuleBasedMatchingConflictResolutionAttributes) ConflictResolvingModel() terra.StringValue {
	return terra.ReferenceAsString(cr.ref.Append("conflict_resolving_model"))
}

func (cr RuleBasedMatchingConflictResolutionAttributes) SourceName() terra.StringValue {
	return terra.ReferenceAsString(cr.ref.Append("source_name"))
}

type RuleBasedMatchingExportingConfigAttributes struct {
	ref terra.Reference
}

func (ec RuleBasedMatchingExportingConfigAttributes) InternalRef() (terra.Reference, error) {
	return ec.ref, nil
}

func (ec RuleBasedMatchingExportingConfigAttributes) InternalWithRef(ref terra.Reference) RuleBasedMatchingExportingConfigAttributes {
	return RuleBasedMatchingExportingConfigAttributes{ref: ref}
}

func (ec RuleBasedMatchingExportingConfigAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return ec.ref.InternalTokens()
}

func (ec RuleBasedMatchingExportingConfigAttributes) S3Exporting() terra.ListValue[RuleBasedMatchingExportingConfigS3ExportingAttributes] {
	return terra.ReferenceAsList[RuleBasedMatchingExportingConfigS3ExportingAttributes](ec.ref.Append("s3_exporting"))
}

type RuleBasedMatchingExportingConfigS3ExportingAttributes struct {
	ref terra.Reference
}

func (se RuleBasedMatchingExportingConfigS3ExportingAttributes) InternalRef() (terra.Reference, error) {
	return se.ref, nil
}

func (se RuleBasedMatchingExportingConfigS3ExportingAttributes) InternalWithRef(ref terra.Reference) RuleBasedMatchingExportingConfigS3ExportingAttributes {
	return RuleBasedMatchingExportingConfigS3ExportingAttributes{ref: ref}
}

func (se RuleBasedMatchingExportingConfigS3ExportingAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return se.ref.InternalTokens()
}

func (se RuleBasedMatchingExportingConfigS3ExportingAttributes) S3BucketName() terra.StringValue {
	return terra.ReferenceAsString(se.ref.Append("s3_bucket_name"))
}

func (se RuleBasedMatchingExportingConfigS3ExportingAttributes) S3KeyName() terra.StringValue {
	return terra.ReferenceAsString(se.ref.Append("s3_key_name"))
}

type RuleBasedMatchingMatchingRulesAttributes struct {
	ref terra.Reference
}

func (mr RuleBasedMatchingMatchingRulesAttributes) InternalRef() (terra.Reference, error) {
	return mr.ref, nil
}

func (mr RuleBasedMatchingMatchingRulesAttributes) InternalWithRef(ref terra.Reference) RuleBasedMatchingMatchingRulesAttributes {
	return RuleBasedMatchingMatchingRulesAttributes{ref: ref}
}

func (mr RuleBasedMatchingMatchingRulesAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return mr.ref.InternalTokens()
}

func (mr RuleBasedMatchingMatchingRulesAttributes) Rule() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](mr.ref.Append("rule"))
}

type MatchingState struct {
	Enabled         bool                           `json:"enabled"`
	AutoMerging     []MatchingAutoMergingState     `json:"auto_merging"`
	ExportingConfig []MatchingExportingConfigState `json:"exporting_config"`
	JobSchedule     []MatchingJobScheduleState     `json:"job_schedule"`
}

type MatchingAutoMergingState struct {
	Enabled                             bool                                         `json:"enabled"`
	MinAllowedConfidenceScoreForMerging float64                                      `json:"min_allowed_confidence_score_for_merging"`
	ConflictResolution                  []MatchingAutoMergingConflictResolutionState `json:"conflict_resolution"`
	Consolidation                       []MatchingAutoMergingConsolidationState      `json:"consolidation"`
}

type MatchingAutoMergingConflictResolutionState struct {
	ConflictResolvingModel string `json:"conflict_resolving_model"`
	SourceName             string `json:"source_name"`
}

type MatchingAutoMergingConsolidationState struct {
	MatchingAttributesList [][]string `json:"matching_attributes_list"`
}

type MatchingExportingConfigState struct {
	S3Exporting []MatchingExportingConfigS3ExportingState `json:"s3_exporting"`
}

type MatchingExportingConfigS3ExportingState struct {
	S3BucketName string `json:"s3_bucket_name"`
	S3KeyName    string `json:"s3_key_name"`
}

type MatchingJobScheduleState struct {
	DayOfTheWeek string `json:"day_of_the_week"`
	Time         string `json:"time"`
}

type RuleBasedMatchingState struct {
	Enabled                        bool                                           `json:"enabled"`
	MaxAllowedRuleLevelForMatching float64                                        `json:"max_allowed_rule_level_for_matching"`
	MaxAllowedRuleLevelForMerging  float64                                        `json:"max_allowed_rule_level_for_merging"`
	Status                         string                                         `json:"status"`
	AttributeTypesSelector         []RuleBasedMatchingAttributeTypesSelectorState `json:"attribute_types_selector"`
	ConflictResolution             []RuleBasedMatchingConflictResolutionState     `json:"conflict_resolution"`
	ExportingConfig                []RuleBasedMatchingExportingConfigState        `json:"exporting_config"`
	MatchingRules                  []RuleBasedMatchingMatchingRulesState          `json:"matching_rules"`
}

type RuleBasedMatchingAttributeTypesSelectorState struct {
	Address                []string `json:"address"`
	AttributeMatchingModel string   `json:"attribute_matching_model"`
	EmailAddress           []string `json:"email_address"`
	PhoneNumber            []string `json:"phone_number"`
}

type RuleBasedMatchingConflictResolutionState struct {
	ConflictResolvingModel string `json:"conflict_resolving_model"`
	SourceName             string `json:"source_name"`
}

type RuleBasedMatchingExportingConfigState struct {
	S3Exporting []RuleBasedMatchingExportingConfigS3ExportingState `json:"s3_exporting"`
}

type RuleBasedMatchingExportingConfigS3ExportingState struct {
	S3BucketName string `json:"s3_bucket_name"`
	S3KeyName    string `json:"s3_key_name"`
}

type RuleBasedMatchingMatchingRulesState struct {
	Rule []string `json:"rule"`
}
