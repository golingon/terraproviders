// CODE GENERATED BY github.com/golingon/lingon. DO NOT EDIT.

package customerprofilesdomain

import (
	terra "github.com/golingon/lingon/pkg/terra"
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
)

type Matching struct {
	// Enabled: bool, required
	Enabled terra.BoolValue `hcl:"enabled,attr" validate:"required"`
	// AutoMerging: optional
	AutoMerging *AutoMerging `hcl:"auto_merging,block"`
	// MatchingExportingConfig: optional
	ExportingConfig *MatchingExportingConfig `hcl:"exporting_config,block"`
	// JobSchedule: optional
	JobSchedule *JobSchedule `hcl:"job_schedule,block"`
}

type AutoMerging struct {
	// Enabled: bool, required
	Enabled terra.BoolValue `hcl:"enabled,attr" validate:"required"`
	// MinAllowedConfidenceScoreForMerging: number, optional
	MinAllowedConfidenceScoreForMerging terra.NumberValue `hcl:"min_allowed_confidence_score_for_merging,attr"`
	// AutoMergingConflictResolution: optional
	ConflictResolution *AutoMergingConflictResolution `hcl:"conflict_resolution,block"`
	// Consolidation: optional
	Consolidation *Consolidation `hcl:"consolidation,block"`
}

type AutoMergingConflictResolution struct {
	// ConflictResolvingModel: string, required
	ConflictResolvingModel terra.StringValue `hcl:"conflict_resolving_model,attr" validate:"required"`
	// SourceName: string, optional
	SourceName terra.StringValue `hcl:"source_name,attr"`
}

type Consolidation struct {
	// MatchingAttributesList: list of list of string, required
	MatchingAttributesList terra.ListValue[terra.ListValue[terra.StringValue]] `hcl:"matching_attributes_list,attr" validate:"required"`
}

type MatchingExportingConfig struct {
	// MatchingExportingConfigS3Exporting: optional
	S3Exporting *MatchingExportingConfigS3Exporting `hcl:"s3_exporting,block"`
}

type MatchingExportingConfigS3Exporting struct {
	// S3BucketName: string, required
	S3BucketName terra.StringValue `hcl:"s3_bucket_name,attr" validate:"required"`
	// S3KeyName: string, optional
	S3KeyName terra.StringValue `hcl:"s3_key_name,attr"`
}

type JobSchedule struct {
	// DayOfTheWeek: string, required
	DayOfTheWeek terra.StringValue `hcl:"day_of_the_week,attr" validate:"required"`
	// Time: string, required
	Time terra.StringValue `hcl:"time,attr" validate:"required"`
}

type RuleBasedMatching struct {
	// Enabled: bool, required
	Enabled terra.BoolValue `hcl:"enabled,attr" validate:"required"`
	// MaxAllowedRuleLevelForMatching: number, optional
	MaxAllowedRuleLevelForMatching terra.NumberValue `hcl:"max_allowed_rule_level_for_matching,attr"`
	// MaxAllowedRuleLevelForMerging: number, optional
	MaxAllowedRuleLevelForMerging terra.NumberValue `hcl:"max_allowed_rule_level_for_merging,attr"`
	// Status: string, optional
	Status terra.StringValue `hcl:"status,attr"`
	// AttributeTypesSelector: optional
	AttributeTypesSelector *AttributeTypesSelector `hcl:"attribute_types_selector,block"`
	// RuleBasedMatchingConflictResolution: optional
	ConflictResolution *RuleBasedMatchingConflictResolution `hcl:"conflict_resolution,block"`
	// RuleBasedMatchingExportingConfig: optional
	ExportingConfig *RuleBasedMatchingExportingConfig `hcl:"exporting_config,block"`
	// MatchingRules: min=0
	MatchingRules []MatchingRules `hcl:"matching_rules,block" validate:"min=0"`
}

type AttributeTypesSelector struct {
	// Address: list of string, optional
	Address terra.ListValue[terra.StringValue] `hcl:"address,attr"`
	// AttributeMatchingModel: string, required
	AttributeMatchingModel terra.StringValue `hcl:"attribute_matching_model,attr" validate:"required"`
	// EmailAddress: list of string, optional
	EmailAddress terra.ListValue[terra.StringValue] `hcl:"email_address,attr"`
	// PhoneNumber: list of string, optional
	PhoneNumber terra.ListValue[terra.StringValue] `hcl:"phone_number,attr"`
}

type RuleBasedMatchingConflictResolution struct {
	// ConflictResolvingModel: string, required
	ConflictResolvingModel terra.StringValue `hcl:"conflict_resolving_model,attr" validate:"required"`
	// SourceName: string, optional
	SourceName terra.StringValue `hcl:"source_name,attr"`
}

type RuleBasedMatchingExportingConfig struct {
	// RuleBasedMatchingExportingConfigS3Exporting: optional
	S3Exporting *RuleBasedMatchingExportingConfigS3Exporting `hcl:"s3_exporting,block"`
}

type RuleBasedMatchingExportingConfigS3Exporting struct {
	// S3BucketName: string, required
	S3BucketName terra.StringValue `hcl:"s3_bucket_name,attr" validate:"required"`
	// S3KeyName: string, optional
	S3KeyName terra.StringValue `hcl:"s3_key_name,attr"`
}

type MatchingRules struct {
	// Rule: list of string, required
	Rule terra.ListValue[terra.StringValue] `hcl:"rule,attr" validate:"required"`
}

type MatchingAttributes struct {
	ref terra.Reference
}

func (m MatchingAttributes) InternalRef() (terra.Reference, error) {
	return m.ref, nil
}

func (m MatchingAttributes) InternalWithRef(ref terra.Reference) MatchingAttributes {
	return MatchingAttributes{ref: ref}
}

func (m MatchingAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return m.ref.InternalTokens()
}

func (m MatchingAttributes) Enabled() terra.BoolValue {
	return terra.ReferenceAsBool(m.ref.Append("enabled"))
}

func (m MatchingAttributes) AutoMerging() terra.ListValue[AutoMergingAttributes] {
	return terra.ReferenceAsList[AutoMergingAttributes](m.ref.Append("auto_merging"))
}

func (m MatchingAttributes) ExportingConfig() terra.ListValue[MatchingExportingConfigAttributes] {
	return terra.ReferenceAsList[MatchingExportingConfigAttributes](m.ref.Append("exporting_config"))
}

func (m MatchingAttributes) JobSchedule() terra.ListValue[JobScheduleAttributes] {
	return terra.ReferenceAsList[JobScheduleAttributes](m.ref.Append("job_schedule"))
}

type AutoMergingAttributes struct {
	ref terra.Reference
}

func (am AutoMergingAttributes) InternalRef() (terra.Reference, error) {
	return am.ref, nil
}

func (am AutoMergingAttributes) InternalWithRef(ref terra.Reference) AutoMergingAttributes {
	return AutoMergingAttributes{ref: ref}
}

func (am AutoMergingAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return am.ref.InternalTokens()
}

func (am AutoMergingAttributes) Enabled() terra.BoolValue {
	return terra.ReferenceAsBool(am.ref.Append("enabled"))
}

func (am AutoMergingAttributes) MinAllowedConfidenceScoreForMerging() terra.NumberValue {
	return terra.ReferenceAsNumber(am.ref.Append("min_allowed_confidence_score_for_merging"))
}

func (am AutoMergingAttributes) ConflictResolution() terra.ListValue[AutoMergingConflictResolutionAttributes] {
	return terra.ReferenceAsList[AutoMergingConflictResolutionAttributes](am.ref.Append("conflict_resolution"))
}

func (am AutoMergingAttributes) Consolidation() terra.ListValue[ConsolidationAttributes] {
	return terra.ReferenceAsList[ConsolidationAttributes](am.ref.Append("consolidation"))
}

type AutoMergingConflictResolutionAttributes struct {
	ref terra.Reference
}

func (cr AutoMergingConflictResolutionAttributes) InternalRef() (terra.Reference, error) {
	return cr.ref, nil
}

func (cr AutoMergingConflictResolutionAttributes) InternalWithRef(ref terra.Reference) AutoMergingConflictResolutionAttributes {
	return AutoMergingConflictResolutionAttributes{ref: ref}
}

func (cr AutoMergingConflictResolutionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cr.ref.InternalTokens()
}

func (cr AutoMergingConflictResolutionAttributes) ConflictResolvingModel() terra.StringValue {
	return terra.ReferenceAsString(cr.ref.Append("conflict_resolving_model"))
}

func (cr AutoMergingConflictResolutionAttributes) SourceName() terra.StringValue {
	return terra.ReferenceAsString(cr.ref.Append("source_name"))
}

type ConsolidationAttributes struct {
	ref terra.Reference
}

func (c ConsolidationAttributes) InternalRef() (terra.Reference, error) {
	return c.ref, nil
}

func (c ConsolidationAttributes) InternalWithRef(ref terra.Reference) ConsolidationAttributes {
	return ConsolidationAttributes{ref: ref}
}

func (c ConsolidationAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return c.ref.InternalTokens()
}

func (c ConsolidationAttributes) MatchingAttributesList() terra.ListValue[terra.ListValue[terra.StringValue]] {
	return terra.ReferenceAsList[terra.ListValue[terra.StringValue]](c.ref.Append("matching_attributes_list"))
}

type MatchingExportingConfigAttributes struct {
	ref terra.Reference
}

func (ec MatchingExportingConfigAttributes) InternalRef() (terra.Reference, error) {
	return ec.ref, nil
}

func (ec MatchingExportingConfigAttributes) InternalWithRef(ref terra.Reference) MatchingExportingConfigAttributes {
	return MatchingExportingConfigAttributes{ref: ref}
}

func (ec MatchingExportingConfigAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return ec.ref.InternalTokens()
}

func (ec MatchingExportingConfigAttributes) S3Exporting() terra.ListValue[MatchingExportingConfigS3ExportingAttributes] {
	return terra.ReferenceAsList[MatchingExportingConfigS3ExportingAttributes](ec.ref.Append("s3_exporting"))
}

type MatchingExportingConfigS3ExportingAttributes struct {
	ref terra.Reference
}

func (se MatchingExportingConfigS3ExportingAttributes) InternalRef() (terra.Reference, error) {
	return se.ref, nil
}

func (se MatchingExportingConfigS3ExportingAttributes) InternalWithRef(ref terra.Reference) MatchingExportingConfigS3ExportingAttributes {
	return MatchingExportingConfigS3ExportingAttributes{ref: ref}
}

func (se MatchingExportingConfigS3ExportingAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return se.ref.InternalTokens()
}

func (se MatchingExportingConfigS3ExportingAttributes) S3BucketName() terra.StringValue {
	return terra.ReferenceAsString(se.ref.Append("s3_bucket_name"))
}

func (se MatchingExportingConfigS3ExportingAttributes) S3KeyName() terra.StringValue {
	return terra.ReferenceAsString(se.ref.Append("s3_key_name"))
}

type JobScheduleAttributes struct {
	ref terra.Reference
}

func (js JobScheduleAttributes) InternalRef() (terra.Reference, error) {
	return js.ref, nil
}

func (js JobScheduleAttributes) InternalWithRef(ref terra.Reference) JobScheduleAttributes {
	return JobScheduleAttributes{ref: ref}
}

func (js JobScheduleAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return js.ref.InternalTokens()
}

func (js JobScheduleAttributes) DayOfTheWeek() terra.StringValue {
	return terra.ReferenceAsString(js.ref.Append("day_of_the_week"))
}

func (js JobScheduleAttributes) Time() terra.StringValue {
	return terra.ReferenceAsString(js.ref.Append("time"))
}

type RuleBasedMatchingAttributes struct {
	ref terra.Reference
}

func (rbm RuleBasedMatchingAttributes) InternalRef() (terra.Reference, error) {
	return rbm.ref, nil
}

func (rbm RuleBasedMatchingAttributes) InternalWithRef(ref terra.Reference) RuleBasedMatchingAttributes {
	return RuleBasedMatchingAttributes{ref: ref}
}

func (rbm RuleBasedMatchingAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return rbm.ref.InternalTokens()
}

func (rbm RuleBasedMatchingAttributes) Enabled() terra.BoolValue {
	return terra.ReferenceAsBool(rbm.ref.Append("enabled"))
}

func (rbm RuleBasedMatchingAttributes) MaxAllowedRuleLevelForMatching() terra.NumberValue {
	return terra.ReferenceAsNumber(rbm.ref.Append("max_allowed_rule_level_for_matching"))
}

func (rbm RuleBasedMatchingAttributes) MaxAllowedRuleLevelForMerging() terra.NumberValue {
	return terra.ReferenceAsNumber(rbm.ref.Append("max_allowed_rule_level_for_merging"))
}

func (rbm RuleBasedMatchingAttributes) Status() terra.StringValue {
	return terra.ReferenceAsString(rbm.ref.Append("status"))
}

func (rbm RuleBasedMatchingAttributes) AttributeTypesSelector() terra.ListValue[AttributeTypesSelectorAttributes] {
	return terra.ReferenceAsList[AttributeTypesSelectorAttributes](rbm.ref.Append("attribute_types_selector"))
}

func (rbm RuleBasedMatchingAttributes) ConflictResolution() terra.ListValue[RuleBasedMatchingConflictResolutionAttributes] {
	return terra.ReferenceAsList[RuleBasedMatchingConflictResolutionAttributes](rbm.ref.Append("conflict_resolution"))
}

func (rbm RuleBasedMatchingAttributes) ExportingConfig() terra.ListValue[RuleBasedMatchingExportingConfigAttributes] {
	return terra.ReferenceAsList[RuleBasedMatchingExportingConfigAttributes](rbm.ref.Append("exporting_config"))
}

func (rbm RuleBasedMatchingAttributes) MatchingRules() terra.SetValue[MatchingRulesAttributes] {
	return terra.ReferenceAsSet[MatchingRulesAttributes](rbm.ref.Append("matching_rules"))
}

type AttributeTypesSelectorAttributes struct {
	ref terra.Reference
}

func (ats AttributeTypesSelectorAttributes) InternalRef() (terra.Reference, error) {
	return ats.ref, nil
}

func (ats AttributeTypesSelectorAttributes) InternalWithRef(ref terra.Reference) AttributeTypesSelectorAttributes {
	return AttributeTypesSelectorAttributes{ref: ref}
}

func (ats AttributeTypesSelectorAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return ats.ref.InternalTokens()
}

func (ats AttributeTypesSelectorAttributes) Address() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](ats.ref.Append("address"))
}

func (ats AttributeTypesSelectorAttributes) AttributeMatchingModel() terra.StringValue {
	return terra.ReferenceAsString(ats.ref.Append("attribute_matching_model"))
}

func (ats AttributeTypesSelectorAttributes) EmailAddress() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](ats.ref.Append("email_address"))
}

func (ats AttributeTypesSelectorAttributes) PhoneNumber() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](ats.ref.Append("phone_number"))
}

type RuleBasedMatchingConflictResolutionAttributes struct {
	ref terra.Reference
}

func (cr RuleBasedMatchingConflictResolutionAttributes) InternalRef() (terra.Reference, error) {
	return cr.ref, nil
}

func (cr RuleBasedMatchingConflictResolutionAttributes) InternalWithRef(ref terra.Reference) RuleBasedMatchingConflictResolutionAttributes {
	return RuleBasedMatchingConflictResolutionAttributes{ref: ref}
}

func (cr RuleBasedMatchingConflictResolutionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cr.ref.InternalTokens()
}

func (cr RuleBasedMatchingConflictResolutionAttributes) ConflictResolvingModel() terra.StringValue {
	return terra.ReferenceAsString(cr.ref.Append("conflict_resolving_model"))
}

func (cr RuleBasedMatchingConflictResolutionAttributes) SourceName() terra.StringValue {
	return terra.ReferenceAsString(cr.ref.Append("source_name"))
}

type RuleBasedMatchingExportingConfigAttributes struct {
	ref terra.Reference
}

func (ec RuleBasedMatchingExportingConfigAttributes) InternalRef() (terra.Reference, error) {
	return ec.ref, nil
}

func (ec RuleBasedMatchingExportingConfigAttributes) InternalWithRef(ref terra.Reference) RuleBasedMatchingExportingConfigAttributes {
	return RuleBasedMatchingExportingConfigAttributes{ref: ref}
}

func (ec RuleBasedMatchingExportingConfigAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return ec.ref.InternalTokens()
}

func (ec RuleBasedMatchingExportingConfigAttributes) S3Exporting() terra.ListValue[RuleBasedMatchingExportingConfigS3ExportingAttributes] {
	return terra.ReferenceAsList[RuleBasedMatchingExportingConfigS3ExportingAttributes](ec.ref.Append("s3_exporting"))
}

type RuleBasedMatchingExportingConfigS3ExportingAttributes struct {
	ref terra.Reference
}

func (se RuleBasedMatchingExportingConfigS3ExportingAttributes) InternalRef() (terra.Reference, error) {
	return se.ref, nil
}

func (se RuleBasedMatchingExportingConfigS3ExportingAttributes) InternalWithRef(ref terra.Reference) RuleBasedMatchingExportingConfigS3ExportingAttributes {
	return RuleBasedMatchingExportingConfigS3ExportingAttributes{ref: ref}
}

func (se RuleBasedMatchingExportingConfigS3ExportingAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return se.ref.InternalTokens()
}

func (se RuleBasedMatchingExportingConfigS3ExportingAttributes) S3BucketName() terra.StringValue {
	return terra.ReferenceAsString(se.ref.Append("s3_bucket_name"))
}

func (se RuleBasedMatchingExportingConfigS3ExportingAttributes) S3KeyName() terra.StringValue {
	return terra.ReferenceAsString(se.ref.Append("s3_key_name"))
}

type MatchingRulesAttributes struct {
	ref terra.Reference
}

func (mr MatchingRulesAttributes) InternalRef() (terra.Reference, error) {
	return mr.ref, nil
}

func (mr MatchingRulesAttributes) InternalWithRef(ref terra.Reference) MatchingRulesAttributes {
	return MatchingRulesAttributes{ref: ref}
}

func (mr MatchingRulesAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return mr.ref.InternalTokens()
}

func (mr MatchingRulesAttributes) Rule() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](mr.ref.Append("rule"))
}

type MatchingState struct {
	Enabled         bool                           `json:"enabled"`
	AutoMerging     []AutoMergingState             `json:"auto_merging"`
	ExportingConfig []MatchingExportingConfigState `json:"exporting_config"`
	JobSchedule     []JobScheduleState             `json:"job_schedule"`
}

type AutoMergingState struct {
	Enabled                             bool                                 `json:"enabled"`
	MinAllowedConfidenceScoreForMerging float64                              `json:"min_allowed_confidence_score_for_merging"`
	ConflictResolution                  []AutoMergingConflictResolutionState `json:"conflict_resolution"`
	Consolidation                       []ConsolidationState                 `json:"consolidation"`
}

type AutoMergingConflictResolutionState struct {
	ConflictResolvingModel string `json:"conflict_resolving_model"`
	SourceName             string `json:"source_name"`
}

type ConsolidationState struct {
	MatchingAttributesList [][]string `json:"matching_attributes_list"`
}

type MatchingExportingConfigState struct {
	S3Exporting []MatchingExportingConfigS3ExportingState `json:"s3_exporting"`
}

type MatchingExportingConfigS3ExportingState struct {
	S3BucketName string `json:"s3_bucket_name"`
	S3KeyName    string `json:"s3_key_name"`
}

type JobScheduleState struct {
	DayOfTheWeek string `json:"day_of_the_week"`
	Time         string `json:"time"`
}

type RuleBasedMatchingState struct {
	Enabled                        bool                                       `json:"enabled"`
	MaxAllowedRuleLevelForMatching float64                                    `json:"max_allowed_rule_level_for_matching"`
	MaxAllowedRuleLevelForMerging  float64                                    `json:"max_allowed_rule_level_for_merging"`
	Status                         string                                     `json:"status"`
	AttributeTypesSelector         []AttributeTypesSelectorState              `json:"attribute_types_selector"`
	ConflictResolution             []RuleBasedMatchingConflictResolutionState `json:"conflict_resolution"`
	ExportingConfig                []RuleBasedMatchingExportingConfigState    `json:"exporting_config"`
	MatchingRules                  []MatchingRulesState                       `json:"matching_rules"`
}

type AttributeTypesSelectorState struct {
	Address                []string `json:"address"`
	AttributeMatchingModel string   `json:"attribute_matching_model"`
	EmailAddress           []string `json:"email_address"`
	PhoneNumber            []string `json:"phone_number"`
}

type RuleBasedMatchingConflictResolutionState struct {
	ConflictResolvingModel string `json:"conflict_resolving_model"`
	SourceName             string `json:"source_name"`
}

type RuleBasedMatchingExportingConfigState struct {
	S3Exporting []RuleBasedMatchingExportingConfigS3ExportingState `json:"s3_exporting"`
}

type RuleBasedMatchingExportingConfigS3ExportingState struct {
	S3BucketName string `json:"s3_bucket_name"`
	S3KeyName    string `json:"s3_key_name"`
}

type MatchingRulesState struct {
	Rule []string `json:"rule"`
}
