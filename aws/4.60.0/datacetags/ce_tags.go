// CODE GENERATED BY github.com/volvo-cars/lingon. DO NOT EDIT.

package datacetags

import (
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
	terra "github.com/volvo-cars/lingon/pkg/terra"
)

type Filter struct {
	// And: min=0
	And []And `hcl:"and,block" validate:"min=0"`
	// FilterCostCategory: optional
	CostCategory *FilterCostCategory `hcl:"cost_category,block"`
	// FilterDimension: optional
	Dimension *FilterDimension `hcl:"dimension,block"`
	// Not: optional
	Not *Not `hcl:"not,block"`
	// Or: min=0
	Or []Or `hcl:"or,block" validate:"min=0"`
	// FilterTags: optional
	Tags *FilterTags `hcl:"tags,block"`
}

type And struct {
	// AndCostCategory: optional
	CostCategory *AndCostCategory `hcl:"cost_category,block"`
	// AndDimension: optional
	Dimension *AndDimension `hcl:"dimension,block"`
	// AndTags: optional
	Tags *AndTags `hcl:"tags,block"`
}

type AndCostCategory struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type AndDimension struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type AndTags struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type FilterCostCategory struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type FilterDimension struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type Not struct {
	// NotCostCategory: optional
	CostCategory *NotCostCategory `hcl:"cost_category,block"`
	// NotDimension: optional
	Dimension *NotDimension `hcl:"dimension,block"`
	// NotTags: optional
	Tags *NotTags `hcl:"tags,block"`
}

type NotCostCategory struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type NotDimension struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type NotTags struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type Or struct {
	// OrCostCategory: optional
	CostCategory *OrCostCategory `hcl:"cost_category,block"`
	// OrDimension: optional
	Dimension *OrDimension `hcl:"dimension,block"`
	// OrTags: optional
	Tags *OrTags `hcl:"tags,block"`
}

type OrCostCategory struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type OrDimension struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type OrTags struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type FilterTags struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type SortBy struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// SortOrder: string, optional
	SortOrder terra.StringValue `hcl:"sort_order,attr"`
}

type TimePeriod struct {
	// End: string, required
	End terra.StringValue `hcl:"end,attr" validate:"required"`
	// Start: string, required
	Start terra.StringValue `hcl:"start,attr" validate:"required"`
}

type FilterAttributes struct {
	ref terra.Reference
}

func (f FilterAttributes) InternalRef() (terra.Reference, error) {
	return f.ref, nil
}

func (f FilterAttributes) InternalWithRef(ref terra.Reference) FilterAttributes {
	return FilterAttributes{ref: ref}
}

func (f FilterAttributes) InternalTokens() hclwrite.Tokens {
	return f.ref.InternalTokens()
}

func (f FilterAttributes) And() terra.SetValue[AndAttributes] {
	return terra.ReferenceAsSet[AndAttributes](f.ref.Append("and"))
}

func (f FilterAttributes) CostCategory() terra.ListValue[FilterCostCategoryAttributes] {
	return terra.ReferenceAsList[FilterCostCategoryAttributes](f.ref.Append("cost_category"))
}

func (f FilterAttributes) Dimension() terra.ListValue[FilterDimensionAttributes] {
	return terra.ReferenceAsList[FilterDimensionAttributes](f.ref.Append("dimension"))
}

func (f FilterAttributes) Not() terra.ListValue[NotAttributes] {
	return terra.ReferenceAsList[NotAttributes](f.ref.Append("not"))
}

func (f FilterAttributes) Or() terra.SetValue[OrAttributes] {
	return terra.ReferenceAsSet[OrAttributes](f.ref.Append("or"))
}

func (f FilterAttributes) Tags() terra.ListValue[FilterTagsAttributes] {
	return terra.ReferenceAsList[FilterTagsAttributes](f.ref.Append("tags"))
}

type AndAttributes struct {
	ref terra.Reference
}

func (a AndAttributes) InternalRef() (terra.Reference, error) {
	return a.ref, nil
}

func (a AndAttributes) InternalWithRef(ref terra.Reference) AndAttributes {
	return AndAttributes{ref: ref}
}

func (a AndAttributes) InternalTokens() hclwrite.Tokens {
	return a.ref.InternalTokens()
}

func (a AndAttributes) CostCategory() terra.ListValue[AndCostCategoryAttributes] {
	return terra.ReferenceAsList[AndCostCategoryAttributes](a.ref.Append("cost_category"))
}

func (a AndAttributes) Dimension() terra.ListValue[AndDimensionAttributes] {
	return terra.ReferenceAsList[AndDimensionAttributes](a.ref.Append("dimension"))
}

func (a AndAttributes) Tags() terra.ListValue[AndTagsAttributes] {
	return terra.ReferenceAsList[AndTagsAttributes](a.ref.Append("tags"))
}

type AndCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc AndCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc AndCostCategoryAttributes) InternalWithRef(ref terra.Reference) AndCostCategoryAttributes {
	return AndCostCategoryAttributes{ref: ref}
}

func (cc AndCostCategoryAttributes) InternalTokens() hclwrite.Tokens {
	return cc.ref.InternalTokens()
}

func (cc AndCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc AndCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc AndCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type AndDimensionAttributes struct {
	ref terra.Reference
}

func (d AndDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d AndDimensionAttributes) InternalWithRef(ref terra.Reference) AndDimensionAttributes {
	return AndDimensionAttributes{ref: ref}
}

func (d AndDimensionAttributes) InternalTokens() hclwrite.Tokens {
	return d.ref.InternalTokens()
}

func (d AndDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d AndDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d AndDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type AndTagsAttributes struct {
	ref terra.Reference
}

func (t AndTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t AndTagsAttributes) InternalWithRef(ref terra.Reference) AndTagsAttributes {
	return AndTagsAttributes{ref: ref}
}

func (t AndTagsAttributes) InternalTokens() hclwrite.Tokens {
	return t.ref.InternalTokens()
}

func (t AndTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t AndTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t AndTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type FilterCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc FilterCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc FilterCostCategoryAttributes) InternalWithRef(ref terra.Reference) FilterCostCategoryAttributes {
	return FilterCostCategoryAttributes{ref: ref}
}

func (cc FilterCostCategoryAttributes) InternalTokens() hclwrite.Tokens {
	return cc.ref.InternalTokens()
}

func (cc FilterCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc FilterCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc FilterCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type FilterDimensionAttributes struct {
	ref terra.Reference
}

func (d FilterDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d FilterDimensionAttributes) InternalWithRef(ref terra.Reference) FilterDimensionAttributes {
	return FilterDimensionAttributes{ref: ref}
}

func (d FilterDimensionAttributes) InternalTokens() hclwrite.Tokens {
	return d.ref.InternalTokens()
}

func (d FilterDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d FilterDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d FilterDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type NotAttributes struct {
	ref terra.Reference
}

func (n NotAttributes) InternalRef() (terra.Reference, error) {
	return n.ref, nil
}

func (n NotAttributes) InternalWithRef(ref terra.Reference) NotAttributes {
	return NotAttributes{ref: ref}
}

func (n NotAttributes) InternalTokens() hclwrite.Tokens {
	return n.ref.InternalTokens()
}

func (n NotAttributes) CostCategory() terra.ListValue[NotCostCategoryAttributes] {
	return terra.ReferenceAsList[NotCostCategoryAttributes](n.ref.Append("cost_category"))
}

func (n NotAttributes) Dimension() terra.ListValue[NotDimensionAttributes] {
	return terra.ReferenceAsList[NotDimensionAttributes](n.ref.Append("dimension"))
}

func (n NotAttributes) Tags() terra.ListValue[NotTagsAttributes] {
	return terra.ReferenceAsList[NotTagsAttributes](n.ref.Append("tags"))
}

type NotCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc NotCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc NotCostCategoryAttributes) InternalWithRef(ref terra.Reference) NotCostCategoryAttributes {
	return NotCostCategoryAttributes{ref: ref}
}

func (cc NotCostCategoryAttributes) InternalTokens() hclwrite.Tokens {
	return cc.ref.InternalTokens()
}

func (cc NotCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc NotCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc NotCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type NotDimensionAttributes struct {
	ref terra.Reference
}

func (d NotDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d NotDimensionAttributes) InternalWithRef(ref terra.Reference) NotDimensionAttributes {
	return NotDimensionAttributes{ref: ref}
}

func (d NotDimensionAttributes) InternalTokens() hclwrite.Tokens {
	return d.ref.InternalTokens()
}

func (d NotDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d NotDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d NotDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type NotTagsAttributes struct {
	ref terra.Reference
}

func (t NotTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t NotTagsAttributes) InternalWithRef(ref terra.Reference) NotTagsAttributes {
	return NotTagsAttributes{ref: ref}
}

func (t NotTagsAttributes) InternalTokens() hclwrite.Tokens {
	return t.ref.InternalTokens()
}

func (t NotTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t NotTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t NotTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type OrAttributes struct {
	ref terra.Reference
}

func (o OrAttributes) InternalRef() (terra.Reference, error) {
	return o.ref, nil
}

func (o OrAttributes) InternalWithRef(ref terra.Reference) OrAttributes {
	return OrAttributes{ref: ref}
}

func (o OrAttributes) InternalTokens() hclwrite.Tokens {
	return o.ref.InternalTokens()
}

func (o OrAttributes) CostCategory() terra.ListValue[OrCostCategoryAttributes] {
	return terra.ReferenceAsList[OrCostCategoryAttributes](o.ref.Append("cost_category"))
}

func (o OrAttributes) Dimension() terra.ListValue[OrDimensionAttributes] {
	return terra.ReferenceAsList[OrDimensionAttributes](o.ref.Append("dimension"))
}

func (o OrAttributes) Tags() terra.ListValue[OrTagsAttributes] {
	return terra.ReferenceAsList[OrTagsAttributes](o.ref.Append("tags"))
}

type OrCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc OrCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc OrCostCategoryAttributes) InternalWithRef(ref terra.Reference) OrCostCategoryAttributes {
	return OrCostCategoryAttributes{ref: ref}
}

func (cc OrCostCategoryAttributes) InternalTokens() hclwrite.Tokens {
	return cc.ref.InternalTokens()
}

func (cc OrCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc OrCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc OrCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type OrDimensionAttributes struct {
	ref terra.Reference
}

func (d OrDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d OrDimensionAttributes) InternalWithRef(ref terra.Reference) OrDimensionAttributes {
	return OrDimensionAttributes{ref: ref}
}

func (d OrDimensionAttributes) InternalTokens() hclwrite.Tokens {
	return d.ref.InternalTokens()
}

func (d OrDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d OrDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d OrDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type OrTagsAttributes struct {
	ref terra.Reference
}

func (t OrTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t OrTagsAttributes) InternalWithRef(ref terra.Reference) OrTagsAttributes {
	return OrTagsAttributes{ref: ref}
}

func (t OrTagsAttributes) InternalTokens() hclwrite.Tokens {
	return t.ref.InternalTokens()
}

func (t OrTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t OrTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t OrTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type FilterTagsAttributes struct {
	ref terra.Reference
}

func (t FilterTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t FilterTagsAttributes) InternalWithRef(ref terra.Reference) FilterTagsAttributes {
	return FilterTagsAttributes{ref: ref}
}

func (t FilterTagsAttributes) InternalTokens() hclwrite.Tokens {
	return t.ref.InternalTokens()
}

func (t FilterTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t FilterTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t FilterTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type SortByAttributes struct {
	ref terra.Reference
}

func (sb SortByAttributes) InternalRef() (terra.Reference, error) {
	return sb.ref, nil
}

func (sb SortByAttributes) InternalWithRef(ref terra.Reference) SortByAttributes {
	return SortByAttributes{ref: ref}
}

func (sb SortByAttributes) InternalTokens() hclwrite.Tokens {
	return sb.ref.InternalTokens()
}

func (sb SortByAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(sb.ref.Append("key"))
}

func (sb SortByAttributes) SortOrder() terra.StringValue {
	return terra.ReferenceAsString(sb.ref.Append("sort_order"))
}

type TimePeriodAttributes struct {
	ref terra.Reference
}

func (tp TimePeriodAttributes) InternalRef() (terra.Reference, error) {
	return tp.ref, nil
}

func (tp TimePeriodAttributes) InternalWithRef(ref terra.Reference) TimePeriodAttributes {
	return TimePeriodAttributes{ref: ref}
}

func (tp TimePeriodAttributes) InternalTokens() hclwrite.Tokens {
	return tp.ref.InternalTokens()
}

func (tp TimePeriodAttributes) End() terra.StringValue {
	return terra.ReferenceAsString(tp.ref.Append("end"))
}

func (tp TimePeriodAttributes) Start() terra.StringValue {
	return terra.ReferenceAsString(tp.ref.Append("start"))
}

type FilterState struct {
	And          []AndState                `json:"and"`
	CostCategory []FilterCostCategoryState `json:"cost_category"`
	Dimension    []FilterDimensionState    `json:"dimension"`
	Not          []NotState                `json:"not"`
	Or           []OrState                 `json:"or"`
	Tags         []FilterTagsState         `json:"tags"`
}

type AndState struct {
	CostCategory []AndCostCategoryState `json:"cost_category"`
	Dimension    []AndDimensionState    `json:"dimension"`
	Tags         []AndTagsState         `json:"tags"`
}

type AndCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type AndDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type AndTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type FilterCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type FilterDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type NotState struct {
	CostCategory []NotCostCategoryState `json:"cost_category"`
	Dimension    []NotDimensionState    `json:"dimension"`
	Tags         []NotTagsState         `json:"tags"`
}

type NotCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type NotDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type NotTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type OrState struct {
	CostCategory []OrCostCategoryState `json:"cost_category"`
	Dimension    []OrDimensionState    `json:"dimension"`
	Tags         []OrTagsState         `json:"tags"`
}

type OrCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type OrDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type OrTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type FilterTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type SortByState struct {
	Key       string `json:"key"`
	SortOrder string `json:"sort_order"`
}

type TimePeriodState struct {
	End   string `json:"end"`
	Start string `json:"start"`
}
