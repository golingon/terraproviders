// CODE GENERATED BY github.com/volvo-cars/lingon. DO NOT EDIT.

package datacecostcategory

import (
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
	terra "github.com/volvo-cars/lingon/pkg/terra"
)

type Rule struct {
	// InheritedValue: min=0
	InheritedValue []InheritedValue `hcl:"inherited_value,block" validate:"min=0"`
	// RuleRule: min=0
	Rule []RuleRule `hcl:"rule,block" validate:"min=0"`
}

type InheritedValue struct{}

type RuleRule struct {
	// And: min=0
	And []And `hcl:"and,block" validate:"min=0"`
	// RuleCostCategory: min=0
	CostCategory []RuleCostCategory `hcl:"cost_category,block" validate:"min=0"`
	// RuleDimension: min=0
	Dimension []RuleDimension `hcl:"dimension,block" validate:"min=0"`
	// Not: min=0
	Not []Not `hcl:"not,block" validate:"min=0"`
	// Or: min=0
	Or []Or `hcl:"or,block" validate:"min=0"`
	// RuleTags: min=0
	Tags []RuleTags `hcl:"tags,block" validate:"min=0"`
}

type And struct {
	// AndCostCategory: min=0
	CostCategory []AndCostCategory `hcl:"cost_category,block" validate:"min=0"`
	// AndDimension: min=0
	Dimension []AndDimension `hcl:"dimension,block" validate:"min=0"`
	// AndTags: min=0
	Tags []AndTags `hcl:"tags,block" validate:"min=0"`
}

type AndCostCategory struct{}

type AndDimension struct{}

type AndTags struct{}

type RuleCostCategory struct{}

type RuleDimension struct{}

type Not struct {
	// NotCostCategory: min=0
	CostCategory []NotCostCategory `hcl:"cost_category,block" validate:"min=0"`
	// NotDimension: min=0
	Dimension []NotDimension `hcl:"dimension,block" validate:"min=0"`
	// NotTags: min=0
	Tags []NotTags `hcl:"tags,block" validate:"min=0"`
}

type NotCostCategory struct{}

type NotDimension struct{}

type NotTags struct{}

type Or struct {
	// OrCostCategory: min=0
	CostCategory []OrCostCategory `hcl:"cost_category,block" validate:"min=0"`
	// OrDimension: min=0
	Dimension []OrDimension `hcl:"dimension,block" validate:"min=0"`
	// OrTags: min=0
	Tags []OrTags `hcl:"tags,block" validate:"min=0"`
}

type OrCostCategory struct{}

type OrDimension struct{}

type OrTags struct{}

type RuleTags struct{}

type SplitChargeRule struct {
	// Parameter: min=0
	Parameter []Parameter `hcl:"parameter,block" validate:"min=0"`
}

type Parameter struct{}

type RuleAttributes struct {
	ref terra.Reference
}

func (r RuleAttributes) InternalRef() (terra.Reference, error) {
	return r.ref, nil
}

func (r RuleAttributes) InternalWithRef(ref terra.Reference) RuleAttributes {
	return RuleAttributes{ref: ref}
}

func (r RuleAttributes) InternalTokens() hclwrite.Tokens {
	return r.ref.InternalTokens()
}

func (r RuleAttributes) Type() terra.StringValue {
	return terra.ReferenceAsString(r.ref.Append("type"))
}

func (r RuleAttributes) Value() terra.StringValue {
	return terra.ReferenceAsString(r.ref.Append("value"))
}

func (r RuleAttributes) InheritedValue() terra.ListValue[InheritedValueAttributes] {
	return terra.ReferenceAsList[InheritedValueAttributes](r.ref.Append("inherited_value"))
}

func (r RuleAttributes) Rule() terra.ListValue[RuleRuleAttributes] {
	return terra.ReferenceAsList[RuleRuleAttributes](r.ref.Append("rule"))
}

type InheritedValueAttributes struct {
	ref terra.Reference
}

func (iv InheritedValueAttributes) InternalRef() (terra.Reference, error) {
	return iv.ref, nil
}

func (iv InheritedValueAttributes) InternalWithRef(ref terra.Reference) InheritedValueAttributes {
	return InheritedValueAttributes{ref: ref}
}

func (iv InheritedValueAttributes) InternalTokens() hclwrite.Tokens {
	return iv.ref.InternalTokens()
}

func (iv InheritedValueAttributes) DimensionKey() terra.StringValue {
	return terra.ReferenceAsString(iv.ref.Append("dimension_key"))
}

func (iv InheritedValueAttributes) DimensionName() terra.StringValue {
	return terra.ReferenceAsString(iv.ref.Append("dimension_name"))
}

type RuleRuleAttributes struct {
	ref terra.Reference
}

func (r RuleRuleAttributes) InternalRef() (terra.Reference, error) {
	return r.ref, nil
}

func (r RuleRuleAttributes) InternalWithRef(ref terra.Reference) RuleRuleAttributes {
	return RuleRuleAttributes{ref: ref}
}

func (r RuleRuleAttributes) InternalTokens() hclwrite.Tokens {
	return r.ref.InternalTokens()
}

func (r RuleRuleAttributes) And() terra.SetValue[AndAttributes] {
	return terra.ReferenceAsSet[AndAttributes](r.ref.Append("and"))
}

func (r RuleRuleAttributes) CostCategory() terra.ListValue[RuleCostCategoryAttributes] {
	return terra.ReferenceAsList[RuleCostCategoryAttributes](r.ref.Append("cost_category"))
}

func (r RuleRuleAttributes) Dimension() terra.ListValue[RuleDimensionAttributes] {
	return terra.ReferenceAsList[RuleDimensionAttributes](r.ref.Append("dimension"))
}

func (r RuleRuleAttributes) Not() terra.ListValue[NotAttributes] {
	return terra.ReferenceAsList[NotAttributes](r.ref.Append("not"))
}

func (r RuleRuleAttributes) Or() terra.SetValue[OrAttributes] {
	return terra.ReferenceAsSet[OrAttributes](r.ref.Append("or"))
}

func (r RuleRuleAttributes) Tags() terra.ListValue[RuleTagsAttributes] {
	return terra.ReferenceAsList[RuleTagsAttributes](r.ref.Append("tags"))
}

type AndAttributes struct {
	ref terra.Reference
}

func (a AndAttributes) InternalRef() (terra.Reference, error) {
	return a.ref, nil
}

func (a AndAttributes) InternalWithRef(ref terra.Reference) AndAttributes {
	return AndAttributes{ref: ref}
}

func (a AndAttributes) InternalTokens() hclwrite.Tokens {
	return a.ref.InternalTokens()
}

func (a AndAttributes) CostCategory() terra.ListValue[AndCostCategoryAttributes] {
	return terra.ReferenceAsList[AndCostCategoryAttributes](a.ref.Append("cost_category"))
}

func (a AndAttributes) Dimension() terra.ListValue[AndDimensionAttributes] {
	return terra.ReferenceAsList[AndDimensionAttributes](a.ref.Append("dimension"))
}

func (a AndAttributes) Tags() terra.ListValue[AndTagsAttributes] {
	return terra.ReferenceAsList[AndTagsAttributes](a.ref.Append("tags"))
}

type AndCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc AndCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc AndCostCategoryAttributes) InternalWithRef(ref terra.Reference) AndCostCategoryAttributes {
	return AndCostCategoryAttributes{ref: ref}
}

func (cc AndCostCategoryAttributes) InternalTokens() hclwrite.Tokens {
	return cc.ref.InternalTokens()
}

func (cc AndCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc AndCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc AndCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type AndDimensionAttributes struct {
	ref terra.Reference
}

func (d AndDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d AndDimensionAttributes) InternalWithRef(ref terra.Reference) AndDimensionAttributes {
	return AndDimensionAttributes{ref: ref}
}

func (d AndDimensionAttributes) InternalTokens() hclwrite.Tokens {
	return d.ref.InternalTokens()
}

func (d AndDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d AndDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d AndDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type AndTagsAttributes struct {
	ref terra.Reference
}

func (t AndTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t AndTagsAttributes) InternalWithRef(ref terra.Reference) AndTagsAttributes {
	return AndTagsAttributes{ref: ref}
}

func (t AndTagsAttributes) InternalTokens() hclwrite.Tokens {
	return t.ref.InternalTokens()
}

func (t AndTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t AndTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t AndTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type RuleCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc RuleCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc RuleCostCategoryAttributes) InternalWithRef(ref terra.Reference) RuleCostCategoryAttributes {
	return RuleCostCategoryAttributes{ref: ref}
}

func (cc RuleCostCategoryAttributes) InternalTokens() hclwrite.Tokens {
	return cc.ref.InternalTokens()
}

func (cc RuleCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc RuleCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc RuleCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type RuleDimensionAttributes struct {
	ref terra.Reference
}

func (d RuleDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d RuleDimensionAttributes) InternalWithRef(ref terra.Reference) RuleDimensionAttributes {
	return RuleDimensionAttributes{ref: ref}
}

func (d RuleDimensionAttributes) InternalTokens() hclwrite.Tokens {
	return d.ref.InternalTokens()
}

func (d RuleDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d RuleDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d RuleDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type NotAttributes struct {
	ref terra.Reference
}

func (n NotAttributes) InternalRef() (terra.Reference, error) {
	return n.ref, nil
}

func (n NotAttributes) InternalWithRef(ref terra.Reference) NotAttributes {
	return NotAttributes{ref: ref}
}

func (n NotAttributes) InternalTokens() hclwrite.Tokens {
	return n.ref.InternalTokens()
}

func (n NotAttributes) CostCategory() terra.ListValue[NotCostCategoryAttributes] {
	return terra.ReferenceAsList[NotCostCategoryAttributes](n.ref.Append("cost_category"))
}

func (n NotAttributes) Dimension() terra.ListValue[NotDimensionAttributes] {
	return terra.ReferenceAsList[NotDimensionAttributes](n.ref.Append("dimension"))
}

func (n NotAttributes) Tags() terra.ListValue[NotTagsAttributes] {
	return terra.ReferenceAsList[NotTagsAttributes](n.ref.Append("tags"))
}

type NotCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc NotCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc NotCostCategoryAttributes) InternalWithRef(ref terra.Reference) NotCostCategoryAttributes {
	return NotCostCategoryAttributes{ref: ref}
}

func (cc NotCostCategoryAttributes) InternalTokens() hclwrite.Tokens {
	return cc.ref.InternalTokens()
}

func (cc NotCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc NotCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc NotCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type NotDimensionAttributes struct {
	ref terra.Reference
}

func (d NotDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d NotDimensionAttributes) InternalWithRef(ref terra.Reference) NotDimensionAttributes {
	return NotDimensionAttributes{ref: ref}
}

func (d NotDimensionAttributes) InternalTokens() hclwrite.Tokens {
	return d.ref.InternalTokens()
}

func (d NotDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d NotDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d NotDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type NotTagsAttributes struct {
	ref terra.Reference
}

func (t NotTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t NotTagsAttributes) InternalWithRef(ref terra.Reference) NotTagsAttributes {
	return NotTagsAttributes{ref: ref}
}

func (t NotTagsAttributes) InternalTokens() hclwrite.Tokens {
	return t.ref.InternalTokens()
}

func (t NotTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t NotTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t NotTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type OrAttributes struct {
	ref terra.Reference
}

func (o OrAttributes) InternalRef() (terra.Reference, error) {
	return o.ref, nil
}

func (o OrAttributes) InternalWithRef(ref terra.Reference) OrAttributes {
	return OrAttributes{ref: ref}
}

func (o OrAttributes) InternalTokens() hclwrite.Tokens {
	return o.ref.InternalTokens()
}

func (o OrAttributes) CostCategory() terra.ListValue[OrCostCategoryAttributes] {
	return terra.ReferenceAsList[OrCostCategoryAttributes](o.ref.Append("cost_category"))
}

func (o OrAttributes) Dimension() terra.ListValue[OrDimensionAttributes] {
	return terra.ReferenceAsList[OrDimensionAttributes](o.ref.Append("dimension"))
}

func (o OrAttributes) Tags() terra.ListValue[OrTagsAttributes] {
	return terra.ReferenceAsList[OrTagsAttributes](o.ref.Append("tags"))
}

type OrCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc OrCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc OrCostCategoryAttributes) InternalWithRef(ref terra.Reference) OrCostCategoryAttributes {
	return OrCostCategoryAttributes{ref: ref}
}

func (cc OrCostCategoryAttributes) InternalTokens() hclwrite.Tokens {
	return cc.ref.InternalTokens()
}

func (cc OrCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc OrCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc OrCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type OrDimensionAttributes struct {
	ref terra.Reference
}

func (d OrDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d OrDimensionAttributes) InternalWithRef(ref terra.Reference) OrDimensionAttributes {
	return OrDimensionAttributes{ref: ref}
}

func (d OrDimensionAttributes) InternalTokens() hclwrite.Tokens {
	return d.ref.InternalTokens()
}

func (d OrDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d OrDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d OrDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type OrTagsAttributes struct {
	ref terra.Reference
}

func (t OrTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t OrTagsAttributes) InternalWithRef(ref terra.Reference) OrTagsAttributes {
	return OrTagsAttributes{ref: ref}
}

func (t OrTagsAttributes) InternalTokens() hclwrite.Tokens {
	return t.ref.InternalTokens()
}

func (t OrTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t OrTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t OrTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type RuleTagsAttributes struct {
	ref terra.Reference
}

func (t RuleTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t RuleTagsAttributes) InternalWithRef(ref terra.Reference) RuleTagsAttributes {
	return RuleTagsAttributes{ref: ref}
}

func (t RuleTagsAttributes) InternalTokens() hclwrite.Tokens {
	return t.ref.InternalTokens()
}

func (t RuleTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t RuleTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t RuleTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type SplitChargeRuleAttributes struct {
	ref terra.Reference
}

func (scr SplitChargeRuleAttributes) InternalRef() (terra.Reference, error) {
	return scr.ref, nil
}

func (scr SplitChargeRuleAttributes) InternalWithRef(ref terra.Reference) SplitChargeRuleAttributes {
	return SplitChargeRuleAttributes{ref: ref}
}

func (scr SplitChargeRuleAttributes) InternalTokens() hclwrite.Tokens {
	return scr.ref.InternalTokens()
}

func (scr SplitChargeRuleAttributes) Method() terra.StringValue {
	return terra.ReferenceAsString(scr.ref.Append("method"))
}

func (scr SplitChargeRuleAttributes) Source() terra.StringValue {
	return terra.ReferenceAsString(scr.ref.Append("source"))
}

func (scr SplitChargeRuleAttributes) Targets() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](scr.ref.Append("targets"))
}

func (scr SplitChargeRuleAttributes) Parameter() terra.SetValue[ParameterAttributes] {
	return terra.ReferenceAsSet[ParameterAttributes](scr.ref.Append("parameter"))
}

type ParameterAttributes struct {
	ref terra.Reference
}

func (p ParameterAttributes) InternalRef() (terra.Reference, error) {
	return p.ref, nil
}

func (p ParameterAttributes) InternalWithRef(ref terra.Reference) ParameterAttributes {
	return ParameterAttributes{ref: ref}
}

func (p ParameterAttributes) InternalTokens() hclwrite.Tokens {
	return p.ref.InternalTokens()
}

func (p ParameterAttributes) Type() terra.StringValue {
	return terra.ReferenceAsString(p.ref.Append("type"))
}

func (p ParameterAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](p.ref.Append("values"))
}

type RuleState struct {
	Type           string                `json:"type"`
	Value          string                `json:"value"`
	InheritedValue []InheritedValueState `json:"inherited_value"`
	Rule           []RuleRuleState       `json:"rule"`
}

type InheritedValueState struct {
	DimensionKey  string `json:"dimension_key"`
	DimensionName string `json:"dimension_name"`
}

type RuleRuleState struct {
	And          []AndState              `json:"and"`
	CostCategory []RuleCostCategoryState `json:"cost_category"`
	Dimension    []RuleDimensionState    `json:"dimension"`
	Not          []NotState              `json:"not"`
	Or           []OrState               `json:"or"`
	Tags         []RuleTagsState         `json:"tags"`
}

type AndState struct {
	CostCategory []AndCostCategoryState `json:"cost_category"`
	Dimension    []AndDimensionState    `json:"dimension"`
	Tags         []AndTagsState         `json:"tags"`
}

type AndCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type AndDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type AndTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type NotState struct {
	CostCategory []NotCostCategoryState `json:"cost_category"`
	Dimension    []NotDimensionState    `json:"dimension"`
	Tags         []NotTagsState         `json:"tags"`
}

type NotCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type NotDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type NotTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type OrState struct {
	CostCategory []OrCostCategoryState `json:"cost_category"`
	Dimension    []OrDimensionState    `json:"dimension"`
	Tags         []OrTagsState         `json:"tags"`
}

type OrCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type OrDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type OrTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type SplitChargeRuleState struct {
	Method    string           `json:"method"`
	Source    string           `json:"source"`
	Targets   []string         `json:"targets"`
	Parameter []ParameterState `json:"parameter"`
}

type ParameterState struct {
	Type   string   `json:"type"`
	Values []string `json:"values"`
}
