// CODE GENERATED BY github.com/volvo-cars/lingon. DO NOT EDIT.

package aws

import (
	"encoding/json"
	"fmt"
	kendrathesaurus "github.com/golingon/terraproviders/aws/4.60.0/kendrathesaurus"
	"github.com/volvo-cars/lingon/pkg/terra"
	"io"
)

func NewKendraThesaurus(name string, args KendraThesaurusArgs) *KendraThesaurus {
	return &KendraThesaurus{
		Args: args,
		Name: name,
	}
}

var _ terra.Resource = (*KendraThesaurus)(nil)

type KendraThesaurus struct {
	Name  string
	Args  KendraThesaurusArgs
	state *kendraThesaurusState
}

func (kt *KendraThesaurus) Type() string {
	return "aws_kendra_thesaurus"
}

func (kt *KendraThesaurus) LocalName() string {
	return kt.Name
}

func (kt *KendraThesaurus) Configuration() interface{} {
	return kt.Args
}

func (kt *KendraThesaurus) Attributes() kendraThesaurusAttributes {
	return kendraThesaurusAttributes{ref: terra.ReferenceResource(kt)}
}

func (kt *KendraThesaurus) ImportState(av io.Reader) error {
	kt.state = &kendraThesaurusState{}
	if err := json.NewDecoder(av).Decode(kt.state); err != nil {
		return fmt.Errorf("decoding state into resource %s.%s: %w", kt.Type(), kt.LocalName(), err)
	}
	return nil
}

func (kt *KendraThesaurus) State() (*kendraThesaurusState, bool) {
	return kt.state, kt.state != nil
}

func (kt *KendraThesaurus) StateMust() *kendraThesaurusState {
	if kt.state == nil {
		panic(fmt.Sprintf("state is nil for resource %s.%s", kt.Type(), kt.LocalName()))
	}
	return kt.state
}

func (kt *KendraThesaurus) DependOn() terra.Reference {
	return terra.ReferenceResource(kt)
}

type KendraThesaurusArgs struct {
	// Description: string, optional
	Description terra.StringValue `hcl:"description,attr"`
	// Id: string, optional
	Id terra.StringValue `hcl:"id,attr"`
	// IndexId: string, required
	IndexId terra.StringValue `hcl:"index_id,attr" validate:"required"`
	// Name: string, required
	Name terra.StringValue `hcl:"name,attr" validate:"required"`
	// RoleArn: string, required
	RoleArn terra.StringValue `hcl:"role_arn,attr" validate:"required"`
	// Tags: map of string, optional
	Tags terra.MapValue[terra.StringValue] `hcl:"tags,attr"`
	// TagsAll: map of string, optional
	TagsAll terra.MapValue[terra.StringValue] `hcl:"tags_all,attr"`
	// SourceS3Path: required
	SourceS3Path *kendrathesaurus.SourceS3Path `hcl:"source_s3_path,block" validate:"required"`
	// Timeouts: optional
	Timeouts *kendrathesaurus.Timeouts `hcl:"timeouts,block"`
	// DependsOn contains resources that KendraThesaurus depends on
	DependsOn terra.Dependencies `hcl:"depends_on,attr"`
}
type kendraThesaurusAttributes struct {
	ref terra.Reference
}

func (kt kendraThesaurusAttributes) Arn() terra.StringValue {
	return terra.ReferenceString(kt.ref.Append("arn"))
}

func (kt kendraThesaurusAttributes) Description() terra.StringValue {
	return terra.ReferenceString(kt.ref.Append("description"))
}

func (kt kendraThesaurusAttributes) Id() terra.StringValue {
	return terra.ReferenceString(kt.ref.Append("id"))
}

func (kt kendraThesaurusAttributes) IndexId() terra.StringValue {
	return terra.ReferenceString(kt.ref.Append("index_id"))
}

func (kt kendraThesaurusAttributes) Name() terra.StringValue {
	return terra.ReferenceString(kt.ref.Append("name"))
}

func (kt kendraThesaurusAttributes) RoleArn() terra.StringValue {
	return terra.ReferenceString(kt.ref.Append("role_arn"))
}

func (kt kendraThesaurusAttributes) Status() terra.StringValue {
	return terra.ReferenceString(kt.ref.Append("status"))
}

func (kt kendraThesaurusAttributes) Tags() terra.MapValue[terra.StringValue] {
	return terra.ReferenceMap[terra.StringValue](kt.ref.Append("tags"))
}

func (kt kendraThesaurusAttributes) TagsAll() terra.MapValue[terra.StringValue] {
	return terra.ReferenceMap[terra.StringValue](kt.ref.Append("tags_all"))
}

func (kt kendraThesaurusAttributes) ThesaurusId() terra.StringValue {
	return terra.ReferenceString(kt.ref.Append("thesaurus_id"))
}

func (kt kendraThesaurusAttributes) SourceS3Path() terra.ListValue[kendrathesaurus.SourceS3PathAttributes] {
	return terra.ReferenceList[kendrathesaurus.SourceS3PathAttributes](kt.ref.Append("source_s3_path"))
}

func (kt kendraThesaurusAttributes) Timeouts() kendrathesaurus.TimeoutsAttributes {
	return terra.ReferenceSingle[kendrathesaurus.TimeoutsAttributes](kt.ref.Append("timeouts"))
}

type kendraThesaurusState struct {
	Arn          string                              `json:"arn"`
	Description  string                              `json:"description"`
	Id           string                              `json:"id"`
	IndexId      string                              `json:"index_id"`
	Name         string                              `json:"name"`
	RoleArn      string                              `json:"role_arn"`
	Status       string                              `json:"status"`
	Tags         map[string]string                   `json:"tags"`
	TagsAll      map[string]string                   `json:"tags_all"`
	ThesaurusId  string                              `json:"thesaurus_id"`
	SourceS3Path []kendrathesaurus.SourceS3PathState `json:"source_s3_path"`
	Timeouts     *kendrathesaurus.TimeoutsState      `json:"timeouts"`
}
