// CODE GENERATED BY github.com/volvo-cars/lingon. DO NOT EDIT.

package accessanalyzerarchiverule

import (
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
	terra "github.com/volvo-cars/lingon/pkg/terra"
)

type Filter struct {
	// Contains: list of string, optional
	Contains terra.ListValue[terra.StringValue] `hcl:"contains,attr"`
	// Criteria: string, required
	Criteria terra.StringValue `hcl:"criteria,attr" validate:"required"`
	// Eq: list of string, optional
	Eq terra.ListValue[terra.StringValue] `hcl:"eq,attr"`
	// Exists: string, optional
	Exists terra.StringValue `hcl:"exists,attr"`
	// Neq: list of string, optional
	Neq terra.ListValue[terra.StringValue] `hcl:"neq,attr"`
}

type FilterAttributes struct {
	ref terra.Reference
}

func (f FilterAttributes) InternalRef() terra.Reference {
	return f.ref
}

func (f FilterAttributes) InternalWithRef(ref terra.Reference) FilterAttributes {
	return FilterAttributes{ref: ref}
}

func (f FilterAttributes) InternalTokens() hclwrite.Tokens {
	return f.ref.InternalTokens()
}

func (f FilterAttributes) Contains() terra.ListValue[terra.StringValue] {
	return terra.ReferenceList[terra.StringValue](f.ref.Append("contains"))
}

func (f FilterAttributes) Criteria() terra.StringValue {
	return terra.ReferenceString(f.ref.Append("criteria"))
}

func (f FilterAttributes) Eq() terra.ListValue[terra.StringValue] {
	return terra.ReferenceList[terra.StringValue](f.ref.Append("eq"))
}

func (f FilterAttributes) Exists() terra.StringValue {
	return terra.ReferenceString(f.ref.Append("exists"))
}

func (f FilterAttributes) Neq() terra.ListValue[terra.StringValue] {
	return terra.ReferenceList[terra.StringValue](f.ref.Append("neq"))
}

type FilterState struct {
	Contains []string `json:"contains"`
	Criteria string   `json:"criteria"`
	Eq       []string `json:"eq"`
	Exists   string   `json:"exists"`
	Neq      []string `json:"neq"`
}
