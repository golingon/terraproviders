// CODE GENERATED BY github.com/volvo-cars/lingon. DO NOT EDIT.

package backupselection

import (
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
	terra "github.com/volvo-cars/lingon/pkg/terra"
)

type Condition struct {
	// StringEquals: min=0
	StringEquals []StringEquals `hcl:"string_equals,block" validate:"min=0"`
	// StringLike: min=0
	StringLike []StringLike `hcl:"string_like,block" validate:"min=0"`
	// StringNotEquals: min=0
	StringNotEquals []StringNotEquals `hcl:"string_not_equals,block" validate:"min=0"`
	// StringNotLike: min=0
	StringNotLike []StringNotLike `hcl:"string_not_like,block" validate:"min=0"`
}

type StringEquals struct {
	// Key: string, required
	Key terra.StringValue `hcl:"key,attr" validate:"required"`
	// Value: string, required
	Value terra.StringValue `hcl:"value,attr" validate:"required"`
}

type StringLike struct {
	// Key: string, required
	Key terra.StringValue `hcl:"key,attr" validate:"required"`
	// Value: string, required
	Value terra.StringValue `hcl:"value,attr" validate:"required"`
}

type StringNotEquals struct {
	// Key: string, required
	Key terra.StringValue `hcl:"key,attr" validate:"required"`
	// Value: string, required
	Value terra.StringValue `hcl:"value,attr" validate:"required"`
}

type StringNotLike struct {
	// Key: string, required
	Key terra.StringValue `hcl:"key,attr" validate:"required"`
	// Value: string, required
	Value terra.StringValue `hcl:"value,attr" validate:"required"`
}

type SelectionTag struct {
	// Key: string, required
	Key terra.StringValue `hcl:"key,attr" validate:"required"`
	// Type: string, required
	Type terra.StringValue `hcl:"type,attr" validate:"required"`
	// Value: string, required
	Value terra.StringValue `hcl:"value,attr" validate:"required"`
}

type ConditionAttributes struct {
	ref terra.Reference
}

func (c ConditionAttributes) InternalRef() terra.Reference {
	return c.ref
}

func (c ConditionAttributes) InternalWithRef(ref terra.Reference) ConditionAttributes {
	return ConditionAttributes{ref: ref}
}

func (c ConditionAttributes) InternalTokens() hclwrite.Tokens {
	return c.ref.InternalTokens()
}

func (c ConditionAttributes) StringEquals() terra.SetValue[StringEqualsAttributes] {
	return terra.ReferenceAsSet[StringEqualsAttributes](c.ref.Append("string_equals"))
}

func (c ConditionAttributes) StringLike() terra.SetValue[StringLikeAttributes] {
	return terra.ReferenceAsSet[StringLikeAttributes](c.ref.Append("string_like"))
}

func (c ConditionAttributes) StringNotEquals() terra.SetValue[StringNotEqualsAttributes] {
	return terra.ReferenceAsSet[StringNotEqualsAttributes](c.ref.Append("string_not_equals"))
}

func (c ConditionAttributes) StringNotLike() terra.SetValue[StringNotLikeAttributes] {
	return terra.ReferenceAsSet[StringNotLikeAttributes](c.ref.Append("string_not_like"))
}

type StringEqualsAttributes struct {
	ref terra.Reference
}

func (se StringEqualsAttributes) InternalRef() terra.Reference {
	return se.ref
}

func (se StringEqualsAttributes) InternalWithRef(ref terra.Reference) StringEqualsAttributes {
	return StringEqualsAttributes{ref: ref}
}

func (se StringEqualsAttributes) InternalTokens() hclwrite.Tokens {
	return se.ref.InternalTokens()
}

func (se StringEqualsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(se.ref.Append("key"))
}

func (se StringEqualsAttributes) Value() terra.StringValue {
	return terra.ReferenceAsString(se.ref.Append("value"))
}

type StringLikeAttributes struct {
	ref terra.Reference
}

func (sl StringLikeAttributes) InternalRef() terra.Reference {
	return sl.ref
}

func (sl StringLikeAttributes) InternalWithRef(ref terra.Reference) StringLikeAttributes {
	return StringLikeAttributes{ref: ref}
}

func (sl StringLikeAttributes) InternalTokens() hclwrite.Tokens {
	return sl.ref.InternalTokens()
}

func (sl StringLikeAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(sl.ref.Append("key"))
}

func (sl StringLikeAttributes) Value() terra.StringValue {
	return terra.ReferenceAsString(sl.ref.Append("value"))
}

type StringNotEqualsAttributes struct {
	ref terra.Reference
}

func (sne StringNotEqualsAttributes) InternalRef() terra.Reference {
	return sne.ref
}

func (sne StringNotEqualsAttributes) InternalWithRef(ref terra.Reference) StringNotEqualsAttributes {
	return StringNotEqualsAttributes{ref: ref}
}

func (sne StringNotEqualsAttributes) InternalTokens() hclwrite.Tokens {
	return sne.ref.InternalTokens()
}

func (sne StringNotEqualsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(sne.ref.Append("key"))
}

func (sne StringNotEqualsAttributes) Value() terra.StringValue {
	return terra.ReferenceAsString(sne.ref.Append("value"))
}

type StringNotLikeAttributes struct {
	ref terra.Reference
}

func (snl StringNotLikeAttributes) InternalRef() terra.Reference {
	return snl.ref
}

func (snl StringNotLikeAttributes) InternalWithRef(ref terra.Reference) StringNotLikeAttributes {
	return StringNotLikeAttributes{ref: ref}
}

func (snl StringNotLikeAttributes) InternalTokens() hclwrite.Tokens {
	return snl.ref.InternalTokens()
}

func (snl StringNotLikeAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(snl.ref.Append("key"))
}

func (snl StringNotLikeAttributes) Value() terra.StringValue {
	return terra.ReferenceAsString(snl.ref.Append("value"))
}

type SelectionTagAttributes struct {
	ref terra.Reference
}

func (st SelectionTagAttributes) InternalRef() terra.Reference {
	return st.ref
}

func (st SelectionTagAttributes) InternalWithRef(ref terra.Reference) SelectionTagAttributes {
	return SelectionTagAttributes{ref: ref}
}

func (st SelectionTagAttributes) InternalTokens() hclwrite.Tokens {
	return st.ref.InternalTokens()
}

func (st SelectionTagAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(st.ref.Append("key"))
}

func (st SelectionTagAttributes) Type() terra.StringValue {
	return terra.ReferenceAsString(st.ref.Append("type"))
}

func (st SelectionTagAttributes) Value() terra.StringValue {
	return terra.ReferenceAsString(st.ref.Append("value"))
}

type ConditionState struct {
	StringEquals    []StringEqualsState    `json:"string_equals"`
	StringLike      []StringLikeState      `json:"string_like"`
	StringNotEquals []StringNotEqualsState `json:"string_not_equals"`
	StringNotLike   []StringNotLikeState   `json:"string_not_like"`
}

type StringEqualsState struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type StringLikeState struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type StringNotEqualsState struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type StringNotLikeState struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type SelectionTagState struct {
	Key   string `json:"key"`
	Type  string `json:"type"`
	Value string `json:"value"`
}
