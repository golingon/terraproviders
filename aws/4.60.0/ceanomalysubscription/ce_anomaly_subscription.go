// CODE GENERATED BY github.com/volvo-cars/lingon. DO NOT EDIT.

package ceanomalysubscription

import (
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
	terra "github.com/volvo-cars/lingon/pkg/terra"
)

type Subscriber struct {
	// Address: string, required
	Address terra.StringValue `hcl:"address,attr" validate:"required"`
	// Type: string, required
	Type terra.StringValue `hcl:"type,attr" validate:"required"`
}

type ThresholdExpression struct {
	// And: min=0
	And []And `hcl:"and,block" validate:"min=0"`
	// ThresholdExpressionCostCategory: optional
	CostCategory *ThresholdExpressionCostCategory `hcl:"cost_category,block"`
	// ThresholdExpressionDimension: optional
	Dimension *ThresholdExpressionDimension `hcl:"dimension,block"`
	// Not: optional
	Not *Not `hcl:"not,block"`
	// Or: min=0
	Or []Or `hcl:"or,block" validate:"min=0"`
	// ThresholdExpressionTags: optional
	Tags *ThresholdExpressionTags `hcl:"tags,block"`
}

type And struct {
	// AndCostCategory: optional
	CostCategory *AndCostCategory `hcl:"cost_category,block"`
	// AndDimension: optional
	Dimension *AndDimension `hcl:"dimension,block"`
	// AndTags: optional
	Tags *AndTags `hcl:"tags,block"`
}

type AndCostCategory struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type AndDimension struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type AndTags struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type ThresholdExpressionCostCategory struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type ThresholdExpressionDimension struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type Not struct {
	// NotCostCategory: optional
	CostCategory *NotCostCategory `hcl:"cost_category,block"`
	// NotDimension: optional
	Dimension *NotDimension `hcl:"dimension,block"`
	// NotTags: optional
	Tags *NotTags `hcl:"tags,block"`
}

type NotCostCategory struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type NotDimension struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type NotTags struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type Or struct {
	// OrCostCategory: optional
	CostCategory *OrCostCategory `hcl:"cost_category,block"`
	// OrDimension: optional
	Dimension *OrDimension `hcl:"dimension,block"`
	// OrTags: optional
	Tags *OrTags `hcl:"tags,block"`
}

type OrCostCategory struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type OrDimension struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type OrTags struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type ThresholdExpressionTags struct {
	// Key: string, optional
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions: set of string, optional
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values: set of string, optional
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type SubscriberAttributes struct {
	ref terra.Reference
}

func (s SubscriberAttributes) InternalRef() terra.Reference {
	return s.ref
}

func (s SubscriberAttributes) InternalWithRef(ref terra.Reference) SubscriberAttributes {
	return SubscriberAttributes{ref: ref}
}

func (s SubscriberAttributes) InternalTokens() hclwrite.Tokens {
	return s.ref.InternalTokens()
}

func (s SubscriberAttributes) Address() terra.StringValue {
	return terra.ReferenceAsString(s.ref.Append("address"))
}

func (s SubscriberAttributes) Type() terra.StringValue {
	return terra.ReferenceAsString(s.ref.Append("type"))
}

type ThresholdExpressionAttributes struct {
	ref terra.Reference
}

func (te ThresholdExpressionAttributes) InternalRef() terra.Reference {
	return te.ref
}

func (te ThresholdExpressionAttributes) InternalWithRef(ref terra.Reference) ThresholdExpressionAttributes {
	return ThresholdExpressionAttributes{ref: ref}
}

func (te ThresholdExpressionAttributes) InternalTokens() hclwrite.Tokens {
	return te.ref.InternalTokens()
}

func (te ThresholdExpressionAttributes) And() terra.SetValue[AndAttributes] {
	return terra.ReferenceAsSet[AndAttributes](te.ref.Append("and"))
}

func (te ThresholdExpressionAttributes) CostCategory() terra.ListValue[ThresholdExpressionCostCategoryAttributes] {
	return terra.ReferenceAsList[ThresholdExpressionCostCategoryAttributes](te.ref.Append("cost_category"))
}

func (te ThresholdExpressionAttributes) Dimension() terra.ListValue[ThresholdExpressionDimensionAttributes] {
	return terra.ReferenceAsList[ThresholdExpressionDimensionAttributes](te.ref.Append("dimension"))
}

func (te ThresholdExpressionAttributes) Not() terra.ListValue[NotAttributes] {
	return terra.ReferenceAsList[NotAttributes](te.ref.Append("not"))
}

func (te ThresholdExpressionAttributes) Or() terra.SetValue[OrAttributes] {
	return terra.ReferenceAsSet[OrAttributes](te.ref.Append("or"))
}

func (te ThresholdExpressionAttributes) Tags() terra.ListValue[ThresholdExpressionTagsAttributes] {
	return terra.ReferenceAsList[ThresholdExpressionTagsAttributes](te.ref.Append("tags"))
}

type AndAttributes struct {
	ref terra.Reference
}

func (a AndAttributes) InternalRef() terra.Reference {
	return a.ref
}

func (a AndAttributes) InternalWithRef(ref terra.Reference) AndAttributes {
	return AndAttributes{ref: ref}
}

func (a AndAttributes) InternalTokens() hclwrite.Tokens {
	return a.ref.InternalTokens()
}

func (a AndAttributes) CostCategory() terra.ListValue[AndCostCategoryAttributes] {
	return terra.ReferenceAsList[AndCostCategoryAttributes](a.ref.Append("cost_category"))
}

func (a AndAttributes) Dimension() terra.ListValue[AndDimensionAttributes] {
	return terra.ReferenceAsList[AndDimensionAttributes](a.ref.Append("dimension"))
}

func (a AndAttributes) Tags() terra.ListValue[AndTagsAttributes] {
	return terra.ReferenceAsList[AndTagsAttributes](a.ref.Append("tags"))
}

type AndCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc AndCostCategoryAttributes) InternalRef() terra.Reference {
	return cc.ref
}

func (cc AndCostCategoryAttributes) InternalWithRef(ref terra.Reference) AndCostCategoryAttributes {
	return AndCostCategoryAttributes{ref: ref}
}

func (cc AndCostCategoryAttributes) InternalTokens() hclwrite.Tokens {
	return cc.ref.InternalTokens()
}

func (cc AndCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc AndCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc AndCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type AndDimensionAttributes struct {
	ref terra.Reference
}

func (d AndDimensionAttributes) InternalRef() terra.Reference {
	return d.ref
}

func (d AndDimensionAttributes) InternalWithRef(ref terra.Reference) AndDimensionAttributes {
	return AndDimensionAttributes{ref: ref}
}

func (d AndDimensionAttributes) InternalTokens() hclwrite.Tokens {
	return d.ref.InternalTokens()
}

func (d AndDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d AndDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d AndDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type AndTagsAttributes struct {
	ref terra.Reference
}

func (t AndTagsAttributes) InternalRef() terra.Reference {
	return t.ref
}

func (t AndTagsAttributes) InternalWithRef(ref terra.Reference) AndTagsAttributes {
	return AndTagsAttributes{ref: ref}
}

func (t AndTagsAttributes) InternalTokens() hclwrite.Tokens {
	return t.ref.InternalTokens()
}

func (t AndTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t AndTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t AndTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type ThresholdExpressionCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc ThresholdExpressionCostCategoryAttributes) InternalRef() terra.Reference {
	return cc.ref
}

func (cc ThresholdExpressionCostCategoryAttributes) InternalWithRef(ref terra.Reference) ThresholdExpressionCostCategoryAttributes {
	return ThresholdExpressionCostCategoryAttributes{ref: ref}
}

func (cc ThresholdExpressionCostCategoryAttributes) InternalTokens() hclwrite.Tokens {
	return cc.ref.InternalTokens()
}

func (cc ThresholdExpressionCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc ThresholdExpressionCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc ThresholdExpressionCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type ThresholdExpressionDimensionAttributes struct {
	ref terra.Reference
}

func (d ThresholdExpressionDimensionAttributes) InternalRef() terra.Reference {
	return d.ref
}

func (d ThresholdExpressionDimensionAttributes) InternalWithRef(ref terra.Reference) ThresholdExpressionDimensionAttributes {
	return ThresholdExpressionDimensionAttributes{ref: ref}
}

func (d ThresholdExpressionDimensionAttributes) InternalTokens() hclwrite.Tokens {
	return d.ref.InternalTokens()
}

func (d ThresholdExpressionDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d ThresholdExpressionDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d ThresholdExpressionDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type NotAttributes struct {
	ref terra.Reference
}

func (n NotAttributes) InternalRef() terra.Reference {
	return n.ref
}

func (n NotAttributes) InternalWithRef(ref terra.Reference) NotAttributes {
	return NotAttributes{ref: ref}
}

func (n NotAttributes) InternalTokens() hclwrite.Tokens {
	return n.ref.InternalTokens()
}

func (n NotAttributes) CostCategory() terra.ListValue[NotCostCategoryAttributes] {
	return terra.ReferenceAsList[NotCostCategoryAttributes](n.ref.Append("cost_category"))
}

func (n NotAttributes) Dimension() terra.ListValue[NotDimensionAttributes] {
	return terra.ReferenceAsList[NotDimensionAttributes](n.ref.Append("dimension"))
}

func (n NotAttributes) Tags() terra.ListValue[NotTagsAttributes] {
	return terra.ReferenceAsList[NotTagsAttributes](n.ref.Append("tags"))
}

type NotCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc NotCostCategoryAttributes) InternalRef() terra.Reference {
	return cc.ref
}

func (cc NotCostCategoryAttributes) InternalWithRef(ref terra.Reference) NotCostCategoryAttributes {
	return NotCostCategoryAttributes{ref: ref}
}

func (cc NotCostCategoryAttributes) InternalTokens() hclwrite.Tokens {
	return cc.ref.InternalTokens()
}

func (cc NotCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc NotCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc NotCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type NotDimensionAttributes struct {
	ref terra.Reference
}

func (d NotDimensionAttributes) InternalRef() terra.Reference {
	return d.ref
}

func (d NotDimensionAttributes) InternalWithRef(ref terra.Reference) NotDimensionAttributes {
	return NotDimensionAttributes{ref: ref}
}

func (d NotDimensionAttributes) InternalTokens() hclwrite.Tokens {
	return d.ref.InternalTokens()
}

func (d NotDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d NotDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d NotDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type NotTagsAttributes struct {
	ref terra.Reference
}

func (t NotTagsAttributes) InternalRef() terra.Reference {
	return t.ref
}

func (t NotTagsAttributes) InternalWithRef(ref terra.Reference) NotTagsAttributes {
	return NotTagsAttributes{ref: ref}
}

func (t NotTagsAttributes) InternalTokens() hclwrite.Tokens {
	return t.ref.InternalTokens()
}

func (t NotTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t NotTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t NotTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type OrAttributes struct {
	ref terra.Reference
}

func (o OrAttributes) InternalRef() terra.Reference {
	return o.ref
}

func (o OrAttributes) InternalWithRef(ref terra.Reference) OrAttributes {
	return OrAttributes{ref: ref}
}

func (o OrAttributes) InternalTokens() hclwrite.Tokens {
	return o.ref.InternalTokens()
}

func (o OrAttributes) CostCategory() terra.ListValue[OrCostCategoryAttributes] {
	return terra.ReferenceAsList[OrCostCategoryAttributes](o.ref.Append("cost_category"))
}

func (o OrAttributes) Dimension() terra.ListValue[OrDimensionAttributes] {
	return terra.ReferenceAsList[OrDimensionAttributes](o.ref.Append("dimension"))
}

func (o OrAttributes) Tags() terra.ListValue[OrTagsAttributes] {
	return terra.ReferenceAsList[OrTagsAttributes](o.ref.Append("tags"))
}

type OrCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc OrCostCategoryAttributes) InternalRef() terra.Reference {
	return cc.ref
}

func (cc OrCostCategoryAttributes) InternalWithRef(ref terra.Reference) OrCostCategoryAttributes {
	return OrCostCategoryAttributes{ref: ref}
}

func (cc OrCostCategoryAttributes) InternalTokens() hclwrite.Tokens {
	return cc.ref.InternalTokens()
}

func (cc OrCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc OrCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc OrCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type OrDimensionAttributes struct {
	ref terra.Reference
}

func (d OrDimensionAttributes) InternalRef() terra.Reference {
	return d.ref
}

func (d OrDimensionAttributes) InternalWithRef(ref terra.Reference) OrDimensionAttributes {
	return OrDimensionAttributes{ref: ref}
}

func (d OrDimensionAttributes) InternalTokens() hclwrite.Tokens {
	return d.ref.InternalTokens()
}

func (d OrDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d OrDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d OrDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type OrTagsAttributes struct {
	ref terra.Reference
}

func (t OrTagsAttributes) InternalRef() terra.Reference {
	return t.ref
}

func (t OrTagsAttributes) InternalWithRef(ref terra.Reference) OrTagsAttributes {
	return OrTagsAttributes{ref: ref}
}

func (t OrTagsAttributes) InternalTokens() hclwrite.Tokens {
	return t.ref.InternalTokens()
}

func (t OrTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t OrTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t OrTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type ThresholdExpressionTagsAttributes struct {
	ref terra.Reference
}

func (t ThresholdExpressionTagsAttributes) InternalRef() terra.Reference {
	return t.ref
}

func (t ThresholdExpressionTagsAttributes) InternalWithRef(ref terra.Reference) ThresholdExpressionTagsAttributes {
	return ThresholdExpressionTagsAttributes{ref: ref}
}

func (t ThresholdExpressionTagsAttributes) InternalTokens() hclwrite.Tokens {
	return t.ref.InternalTokens()
}

func (t ThresholdExpressionTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t ThresholdExpressionTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t ThresholdExpressionTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type SubscriberState struct {
	Address string `json:"address"`
	Type    string `json:"type"`
}

type ThresholdExpressionState struct {
	And          []AndState                             `json:"and"`
	CostCategory []ThresholdExpressionCostCategoryState `json:"cost_category"`
	Dimension    []ThresholdExpressionDimensionState    `json:"dimension"`
	Not          []NotState                             `json:"not"`
	Or           []OrState                              `json:"or"`
	Tags         []ThresholdExpressionTagsState         `json:"tags"`
}

type AndState struct {
	CostCategory []AndCostCategoryState `json:"cost_category"`
	Dimension    []AndDimensionState    `json:"dimension"`
	Tags         []AndTagsState         `json:"tags"`
}

type AndCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type AndDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type AndTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type ThresholdExpressionCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type ThresholdExpressionDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type NotState struct {
	CostCategory []NotCostCategoryState `json:"cost_category"`
	Dimension    []NotDimensionState    `json:"dimension"`
	Tags         []NotTagsState         `json:"tags"`
}

type NotCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type NotDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type NotTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type OrState struct {
	CostCategory []OrCostCategoryState `json:"cost_category"`
	Dimension    []OrDimensionState    `json:"dimension"`
	Tags         []OrTagsState         `json:"tags"`
}

type OrCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type OrDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type OrTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type ThresholdExpressionTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}
