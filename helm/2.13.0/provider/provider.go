// CODE GENERATED BY github.com/golingon/lingon. DO NOT EDIT.

package provider

import (
	terra "github.com/golingon/lingon/pkg/terra"
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
)

type Experiments struct {
	// Manifest: bool, optional
	Manifest terra.BoolValue `hcl:"manifest,attr"`
}

type Kubernetes struct {
	// ClientCertificate: string, optional
	ClientCertificate terra.StringValue `hcl:"client_certificate,attr"`
	// ClientKey: string, optional
	ClientKey terra.StringValue `hcl:"client_key,attr"`
	// ClusterCaCertificate: string, optional
	ClusterCaCertificate terra.StringValue `hcl:"cluster_ca_certificate,attr"`
	// ConfigContext: string, optional
	ConfigContext terra.StringValue `hcl:"config_context,attr"`
	// ConfigContextAuthInfo: string, optional
	ConfigContextAuthInfo terra.StringValue `hcl:"config_context_auth_info,attr"`
	// ConfigContextCluster: string, optional
	ConfigContextCluster terra.StringValue `hcl:"config_context_cluster,attr"`
	// ConfigPath: string, optional
	ConfigPath terra.StringValue `hcl:"config_path,attr"`
	// ConfigPaths: list of string, optional
	ConfigPaths terra.ListValue[terra.StringValue] `hcl:"config_paths,attr"`
	// Host: string, optional
	Host terra.StringValue `hcl:"host,attr"`
	// Insecure: bool, optional
	Insecure terra.BoolValue `hcl:"insecure,attr"`
	// Password: string, optional
	Password terra.StringValue `hcl:"password,attr"`
	// ProxyUrl: string, optional
	ProxyUrl terra.StringValue `hcl:"proxy_url,attr"`
	// TlsServerName: string, optional
	TlsServerName terra.StringValue `hcl:"tls_server_name,attr"`
	// Token: string, optional
	Token terra.StringValue `hcl:"token,attr"`
	// Username: string, optional
	Username terra.StringValue `hcl:"username,attr"`
	// Exec: optional
	Exec *Exec `hcl:"exec,block"`
}

type Exec struct {
	// ApiVersion: string, required
	ApiVersion terra.StringValue `hcl:"api_version,attr" validate:"required"`
	// Args: list of string, optional
	Args terra.ListValue[terra.StringValue] `hcl:"args,attr"`
	// Command: string, required
	Command terra.StringValue `hcl:"command,attr" validate:"required"`
	// Env: map of string, optional
	Env terra.MapValue[terra.StringValue] `hcl:"env,attr"`
}

type Registry struct {
	// Password: string, required
	Password terra.StringValue `hcl:"password,attr" validate:"required"`
	// Url: string, required
	Url terra.StringValue `hcl:"url,attr" validate:"required"`
	// Username: string, required
	Username terra.StringValue `hcl:"username,attr" validate:"required"`
}

type ExperimentsAttributes struct {
	ref terra.Reference
}

func (e ExperimentsAttributes) InternalRef() (terra.Reference, error) {
	return e.ref, nil
}

func (e ExperimentsAttributes) InternalWithRef(ref terra.Reference) ExperimentsAttributes {
	return ExperimentsAttributes{ref: ref}
}

func (e ExperimentsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return e.ref.InternalTokens()
}

func (e ExperimentsAttributes) Manifest() terra.BoolValue {
	return terra.ReferenceAsBool(e.ref.Append("manifest"))
}

type KubernetesAttributes struct {
	ref terra.Reference
}

func (k KubernetesAttributes) InternalRef() (terra.Reference, error) {
	return k.ref, nil
}

func (k KubernetesAttributes) InternalWithRef(ref terra.Reference) KubernetesAttributes {
	return KubernetesAttributes{ref: ref}
}

func (k KubernetesAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return k.ref.InternalTokens()
}

func (k KubernetesAttributes) ClientCertificate() terra.StringValue {
	return terra.ReferenceAsString(k.ref.Append("client_certificate"))
}

func (k KubernetesAttributes) ClientKey() terra.StringValue {
	return terra.ReferenceAsString(k.ref.Append("client_key"))
}

func (k KubernetesAttributes) ClusterCaCertificate() terra.StringValue {
	return terra.ReferenceAsString(k.ref.Append("cluster_ca_certificate"))
}

func (k KubernetesAttributes) ConfigContext() terra.StringValue {
	return terra.ReferenceAsString(k.ref.Append("config_context"))
}

func (k KubernetesAttributes) ConfigContextAuthInfo() terra.StringValue {
	return terra.ReferenceAsString(k.ref.Append("config_context_auth_info"))
}

func (k KubernetesAttributes) ConfigContextCluster() terra.StringValue {
	return terra.ReferenceAsString(k.ref.Append("config_context_cluster"))
}

func (k KubernetesAttributes) ConfigPath() terra.StringValue {
	return terra.ReferenceAsString(k.ref.Append("config_path"))
}

func (k KubernetesAttributes) ConfigPaths() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](k.ref.Append("config_paths"))
}

func (k KubernetesAttributes) Host() terra.StringValue {
	return terra.ReferenceAsString(k.ref.Append("host"))
}

func (k KubernetesAttributes) Insecure() terra.BoolValue {
	return terra.ReferenceAsBool(k.ref.Append("insecure"))
}

func (k KubernetesAttributes) Password() terra.StringValue {
	return terra.ReferenceAsString(k.ref.Append("password"))
}

func (k KubernetesAttributes) ProxyUrl() terra.StringValue {
	return terra.ReferenceAsString(k.ref.Append("proxy_url"))
}

func (k KubernetesAttributes) TlsServerName() terra.StringValue {
	return terra.ReferenceAsString(k.ref.Append("tls_server_name"))
}

func (k KubernetesAttributes) Token() terra.StringValue {
	return terra.ReferenceAsString(k.ref.Append("token"))
}

func (k KubernetesAttributes) Username() terra.StringValue {
	return terra.ReferenceAsString(k.ref.Append("username"))
}

func (k KubernetesAttributes) Exec() terra.ListValue[ExecAttributes] {
	return terra.ReferenceAsList[ExecAttributes](k.ref.Append("exec"))
}

type ExecAttributes struct {
	ref terra.Reference
}

func (e ExecAttributes) InternalRef() (terra.Reference, error) {
	return e.ref, nil
}

func (e ExecAttributes) InternalWithRef(ref terra.Reference) ExecAttributes {
	return ExecAttributes{ref: ref}
}

func (e ExecAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return e.ref.InternalTokens()
}

func (e ExecAttributes) ApiVersion() terra.StringValue {
	return terra.ReferenceAsString(e.ref.Append("api_version"))
}

func (e ExecAttributes) Args() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](e.ref.Append("args"))
}

func (e ExecAttributes) Command() terra.StringValue {
	return terra.ReferenceAsString(e.ref.Append("command"))
}

func (e ExecAttributes) Env() terra.MapValue[terra.StringValue] {
	return terra.ReferenceAsMap[terra.StringValue](e.ref.Append("env"))
}

type RegistryAttributes struct {
	ref terra.Reference
}

func (r RegistryAttributes) InternalRef() (terra.Reference, error) {
	return r.ref, nil
}

func (r RegistryAttributes) InternalWithRef(ref terra.Reference) RegistryAttributes {
	return RegistryAttributes{ref: ref}
}

func (r RegistryAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return r.ref.InternalTokens()
}

func (r RegistryAttributes) Password() terra.StringValue {
	return terra.ReferenceAsString(r.ref.Append("password"))
}

func (r RegistryAttributes) Url() terra.StringValue {
	return terra.ReferenceAsString(r.ref.Append("url"))
}

func (r RegistryAttributes) Username() terra.StringValue {
	return terra.ReferenceAsString(r.ref.Append("username"))
}

type ExperimentsState struct {
	Manifest bool `json:"manifest"`
}

type KubernetesState struct {
	ClientCertificate     string      `json:"client_certificate"`
	ClientKey             string      `json:"client_key"`
	ClusterCaCertificate  string      `json:"cluster_ca_certificate"`
	ConfigContext         string      `json:"config_context"`
	ConfigContextAuthInfo string      `json:"config_context_auth_info"`
	ConfigContextCluster  string      `json:"config_context_cluster"`
	ConfigPath            string      `json:"config_path"`
	ConfigPaths           []string    `json:"config_paths"`
	Host                  string      `json:"host"`
	Insecure              bool        `json:"insecure"`
	Password              string      `json:"password"`
	ProxyUrl              string      `json:"proxy_url"`
	TlsServerName         string      `json:"tls_server_name"`
	Token                 string      `json:"token"`
	Username              string      `json:"username"`
	Exec                  []ExecState `json:"exec"`
}

type ExecState struct {
	ApiVersion string            `json:"api_version"`
	Args       []string          `json:"args"`
	Command    string            `json:"command"`
	Env        map[string]string `json:"env"`
}

type RegistryState struct {
	Password string `json:"password"`
	Url      string `json:"url"`
	Username string `json:"username"`
}
