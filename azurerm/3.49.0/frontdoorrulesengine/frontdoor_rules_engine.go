// CODE GENERATED BY github.com/volvo-cars/lingon. DO NOT EDIT.

package frontdoorrulesengine

import (
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
	terra "github.com/volvo-cars/lingon/pkg/terra"
)

type Rule struct {
	// Name: string, required
	Name terra.StringValue `hcl:"name,attr" validate:"required"`
	// Priority: number, required
	Priority terra.NumberValue `hcl:"priority,attr" validate:"required"`
	// Action: optional
	Action *Action `hcl:"action,block"`
	// MatchCondition: min=0,max=100
	MatchCondition []MatchCondition `hcl:"match_condition,block" validate:"min=0,max=100"`
}

type Action struct {
	// RequestHeader: min=0,max=100
	RequestHeader []RequestHeader `hcl:"request_header,block" validate:"min=0,max=100"`
	// ResponseHeader: min=0,max=100
	ResponseHeader []ResponseHeader `hcl:"response_header,block" validate:"min=0,max=100"`
}

type RequestHeader struct {
	// HeaderActionType: string, optional
	HeaderActionType terra.StringValue `hcl:"header_action_type,attr"`
	// HeaderName: string, optional
	HeaderName terra.StringValue `hcl:"header_name,attr"`
	// Value: string, optional
	Value terra.StringValue `hcl:"value,attr"`
}

type ResponseHeader struct {
	// HeaderActionType: string, optional
	HeaderActionType terra.StringValue `hcl:"header_action_type,attr"`
	// HeaderName: string, optional
	HeaderName terra.StringValue `hcl:"header_name,attr"`
	// Value: string, optional
	Value terra.StringValue `hcl:"value,attr"`
}

type MatchCondition struct {
	// NegateCondition: bool, optional
	NegateCondition terra.BoolValue `hcl:"negate_condition,attr"`
	// Operator: string, required
	Operator terra.StringValue `hcl:"operator,attr" validate:"required"`
	// Selector: string, optional
	Selector terra.StringValue `hcl:"selector,attr"`
	// Transform: list of string, optional
	Transform terra.ListValue[terra.StringValue] `hcl:"transform,attr"`
	// Value: list of string, optional
	Value terra.ListValue[terra.StringValue] `hcl:"value,attr"`
	// Variable: string, optional
	Variable terra.StringValue `hcl:"variable,attr"`
}

type Timeouts struct {
	// Create: string, optional
	Create terra.StringValue `hcl:"create,attr"`
	// Delete: string, optional
	Delete terra.StringValue `hcl:"delete,attr"`
	// Read: string, optional
	Read terra.StringValue `hcl:"read,attr"`
	// Update: string, optional
	Update terra.StringValue `hcl:"update,attr"`
}

type RuleAttributes struct {
	ref terra.Reference
}

func (r RuleAttributes) InternalRef() terra.Reference {
	return r.ref
}

func (r RuleAttributes) InternalWithRef(ref terra.Reference) RuleAttributes {
	return RuleAttributes{ref: ref}
}

func (r RuleAttributes) InternalTokens() hclwrite.Tokens {
	return r.ref.InternalTokens()
}

func (r RuleAttributes) Name() terra.StringValue {
	return terra.ReferenceString(r.ref.Append("name"))
}

func (r RuleAttributes) Priority() terra.NumberValue {
	return terra.ReferenceNumber(r.ref.Append("priority"))
}

func (r RuleAttributes) Action() terra.ListValue[ActionAttributes] {
	return terra.ReferenceList[ActionAttributes](r.ref.Append("action"))
}

func (r RuleAttributes) MatchCondition() terra.ListValue[MatchConditionAttributes] {
	return terra.ReferenceList[MatchConditionAttributes](r.ref.Append("match_condition"))
}

type ActionAttributes struct {
	ref terra.Reference
}

func (a ActionAttributes) InternalRef() terra.Reference {
	return a.ref
}

func (a ActionAttributes) InternalWithRef(ref terra.Reference) ActionAttributes {
	return ActionAttributes{ref: ref}
}

func (a ActionAttributes) InternalTokens() hclwrite.Tokens {
	return a.ref.InternalTokens()
}

func (a ActionAttributes) RequestHeader() terra.ListValue[RequestHeaderAttributes] {
	return terra.ReferenceList[RequestHeaderAttributes](a.ref.Append("request_header"))
}

func (a ActionAttributes) ResponseHeader() terra.ListValue[ResponseHeaderAttributes] {
	return terra.ReferenceList[ResponseHeaderAttributes](a.ref.Append("response_header"))
}

type RequestHeaderAttributes struct {
	ref terra.Reference
}

func (rh RequestHeaderAttributes) InternalRef() terra.Reference {
	return rh.ref
}

func (rh RequestHeaderAttributes) InternalWithRef(ref terra.Reference) RequestHeaderAttributes {
	return RequestHeaderAttributes{ref: ref}
}

func (rh RequestHeaderAttributes) InternalTokens() hclwrite.Tokens {
	return rh.ref.InternalTokens()
}

func (rh RequestHeaderAttributes) HeaderActionType() terra.StringValue {
	return terra.ReferenceString(rh.ref.Append("header_action_type"))
}

func (rh RequestHeaderAttributes) HeaderName() terra.StringValue {
	return terra.ReferenceString(rh.ref.Append("header_name"))
}

func (rh RequestHeaderAttributes) Value() terra.StringValue {
	return terra.ReferenceString(rh.ref.Append("value"))
}

type ResponseHeaderAttributes struct {
	ref terra.Reference
}

func (rh ResponseHeaderAttributes) InternalRef() terra.Reference {
	return rh.ref
}

func (rh ResponseHeaderAttributes) InternalWithRef(ref terra.Reference) ResponseHeaderAttributes {
	return ResponseHeaderAttributes{ref: ref}
}

func (rh ResponseHeaderAttributes) InternalTokens() hclwrite.Tokens {
	return rh.ref.InternalTokens()
}

func (rh ResponseHeaderAttributes) HeaderActionType() terra.StringValue {
	return terra.ReferenceString(rh.ref.Append("header_action_type"))
}

func (rh ResponseHeaderAttributes) HeaderName() terra.StringValue {
	return terra.ReferenceString(rh.ref.Append("header_name"))
}

func (rh ResponseHeaderAttributes) Value() terra.StringValue {
	return terra.ReferenceString(rh.ref.Append("value"))
}

type MatchConditionAttributes struct {
	ref terra.Reference
}

func (mc MatchConditionAttributes) InternalRef() terra.Reference {
	return mc.ref
}

func (mc MatchConditionAttributes) InternalWithRef(ref terra.Reference) MatchConditionAttributes {
	return MatchConditionAttributes{ref: ref}
}

func (mc MatchConditionAttributes) InternalTokens() hclwrite.Tokens {
	return mc.ref.InternalTokens()
}

func (mc MatchConditionAttributes) NegateCondition() terra.BoolValue {
	return terra.ReferenceBool(mc.ref.Append("negate_condition"))
}

func (mc MatchConditionAttributes) Operator() terra.StringValue {
	return terra.ReferenceString(mc.ref.Append("operator"))
}

func (mc MatchConditionAttributes) Selector() terra.StringValue {
	return terra.ReferenceString(mc.ref.Append("selector"))
}

func (mc MatchConditionAttributes) Transform() terra.ListValue[terra.StringValue] {
	return terra.ReferenceList[terra.StringValue](mc.ref.Append("transform"))
}

func (mc MatchConditionAttributes) Value() terra.ListValue[terra.StringValue] {
	return terra.ReferenceList[terra.StringValue](mc.ref.Append("value"))
}

func (mc MatchConditionAttributes) Variable() terra.StringValue {
	return terra.ReferenceString(mc.ref.Append("variable"))
}

type TimeoutsAttributes struct {
	ref terra.Reference
}

func (t TimeoutsAttributes) InternalRef() terra.Reference {
	return t.ref
}

func (t TimeoutsAttributes) InternalWithRef(ref terra.Reference) TimeoutsAttributes {
	return TimeoutsAttributes{ref: ref}
}

func (t TimeoutsAttributes) InternalTokens() hclwrite.Tokens {
	return t.ref.InternalTokens()
}

func (t TimeoutsAttributes) Create() terra.StringValue {
	return terra.ReferenceString(t.ref.Append("create"))
}

func (t TimeoutsAttributes) Delete() terra.StringValue {
	return terra.ReferenceString(t.ref.Append("delete"))
}

func (t TimeoutsAttributes) Read() terra.StringValue {
	return terra.ReferenceString(t.ref.Append("read"))
}

func (t TimeoutsAttributes) Update() terra.StringValue {
	return terra.ReferenceString(t.ref.Append("update"))
}

type RuleState struct {
	Name           string                `json:"name"`
	Priority       float64               `json:"priority"`
	Action         []ActionState         `json:"action"`
	MatchCondition []MatchConditionState `json:"match_condition"`
}

type ActionState struct {
	RequestHeader  []RequestHeaderState  `json:"request_header"`
	ResponseHeader []ResponseHeaderState `json:"response_header"`
}

type RequestHeaderState struct {
	HeaderActionType string `json:"header_action_type"`
	HeaderName       string `json:"header_name"`
	Value            string `json:"value"`
}

type ResponseHeaderState struct {
	HeaderActionType string `json:"header_action_type"`
	HeaderName       string `json:"header_name"`
	Value            string `json:"value"`
}

type MatchConditionState struct {
	NegateCondition bool     `json:"negate_condition"`
	Operator        string   `json:"operator"`
	Selector        string   `json:"selector"`
	Transform       []string `json:"transform"`
	Value           []string `json:"value"`
	Variable        string   `json:"variable"`
}

type TimeoutsState struct {
	Create string `json:"create"`
	Delete string `json:"delete"`
	Read   string `json:"read"`
	Update string `json:"update"`
}
