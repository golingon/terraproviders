// CODE GENERATED BY github.com/volvo-cars/lingon. DO NOT EDIT.

package networksecurityauthorizationpolicy

import (
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
	terra "github.com/volvo-cars/lingon/pkg/terra"
)

type Rules struct {
	// Destinations: min=0
	Destinations []Destinations `hcl:"destinations,block" validate:"min=0"`
	// Sources: min=0
	Sources []Sources `hcl:"sources,block" validate:"min=0"`
}

type Destinations struct {
	// Hosts: list of string, required
	Hosts terra.ListValue[terra.StringValue] `hcl:"hosts,attr" validate:"required"`
	// Methods: list of string, required
	Methods terra.ListValue[terra.StringValue] `hcl:"methods,attr" validate:"required"`
	// Ports: list of number, required
	Ports terra.ListValue[terra.NumberValue] `hcl:"ports,attr" validate:"required"`
	// HttpHeaderMatch: optional
	HttpHeaderMatch *HttpHeaderMatch `hcl:"http_header_match,block"`
}

type HttpHeaderMatch struct {
	// HeaderName: string, required
	HeaderName terra.StringValue `hcl:"header_name,attr" validate:"required"`
	// RegexMatch: string, required
	RegexMatch terra.StringValue `hcl:"regex_match,attr" validate:"required"`
}

type Sources struct {
	// IpBlocks: list of string, optional
	IpBlocks terra.ListValue[terra.StringValue] `hcl:"ip_blocks,attr"`
	// Principals: list of string, optional
	Principals terra.ListValue[terra.StringValue] `hcl:"principals,attr"`
}

type Timeouts struct {
	// Create: string, optional
	Create terra.StringValue `hcl:"create,attr"`
	// Delete: string, optional
	Delete terra.StringValue `hcl:"delete,attr"`
	// Update: string, optional
	Update terra.StringValue `hcl:"update,attr"`
}

type RulesAttributes struct {
	ref terra.Reference
}

func (r RulesAttributes) InternalRef() (terra.Reference, error) {
	return r.ref, nil
}

func (r RulesAttributes) InternalWithRef(ref terra.Reference) RulesAttributes {
	return RulesAttributes{ref: ref}
}

func (r RulesAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return r.ref.InternalTokens()
}

func (r RulesAttributes) Destinations() terra.ListValue[DestinationsAttributes] {
	return terra.ReferenceAsList[DestinationsAttributes](r.ref.Append("destinations"))
}

func (r RulesAttributes) Sources() terra.ListValue[SourcesAttributes] {
	return terra.ReferenceAsList[SourcesAttributes](r.ref.Append("sources"))
}

type DestinationsAttributes struct {
	ref terra.Reference
}

func (d DestinationsAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d DestinationsAttributes) InternalWithRef(ref terra.Reference) DestinationsAttributes {
	return DestinationsAttributes{ref: ref}
}

func (d DestinationsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return d.ref.InternalTokens()
}

func (d DestinationsAttributes) Hosts() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](d.ref.Append("hosts"))
}

func (d DestinationsAttributes) Methods() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](d.ref.Append("methods"))
}

func (d DestinationsAttributes) Ports() terra.ListValue[terra.NumberValue] {
	return terra.ReferenceAsList[terra.NumberValue](d.ref.Append("ports"))
}

func (d DestinationsAttributes) HttpHeaderMatch() terra.ListValue[HttpHeaderMatchAttributes] {
	return terra.ReferenceAsList[HttpHeaderMatchAttributes](d.ref.Append("http_header_match"))
}

type HttpHeaderMatchAttributes struct {
	ref terra.Reference
}

func (hhm HttpHeaderMatchAttributes) InternalRef() (terra.Reference, error) {
	return hhm.ref, nil
}

func (hhm HttpHeaderMatchAttributes) InternalWithRef(ref terra.Reference) HttpHeaderMatchAttributes {
	return HttpHeaderMatchAttributes{ref: ref}
}

func (hhm HttpHeaderMatchAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return hhm.ref.InternalTokens()
}

func (hhm HttpHeaderMatchAttributes) HeaderName() terra.StringValue {
	return terra.ReferenceAsString(hhm.ref.Append("header_name"))
}

func (hhm HttpHeaderMatchAttributes) RegexMatch() terra.StringValue {
	return terra.ReferenceAsString(hhm.ref.Append("regex_match"))
}

type SourcesAttributes struct {
	ref terra.Reference
}

func (s SourcesAttributes) InternalRef() (terra.Reference, error) {
	return s.ref, nil
}

func (s SourcesAttributes) InternalWithRef(ref terra.Reference) SourcesAttributes {
	return SourcesAttributes{ref: ref}
}

func (s SourcesAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return s.ref.InternalTokens()
}

func (s SourcesAttributes) IpBlocks() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](s.ref.Append("ip_blocks"))
}

func (s SourcesAttributes) Principals() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](s.ref.Append("principals"))
}

type TimeoutsAttributes struct {
	ref terra.Reference
}

func (t TimeoutsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t TimeoutsAttributes) InternalWithRef(ref terra.Reference) TimeoutsAttributes {
	return TimeoutsAttributes{ref: ref}
}

func (t TimeoutsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return t.ref.InternalTokens()
}

func (t TimeoutsAttributes) Create() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("create"))
}

func (t TimeoutsAttributes) Delete() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("delete"))
}

func (t TimeoutsAttributes) Update() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("update"))
}

type RulesState struct {
	Destinations []DestinationsState `json:"destinations"`
	Sources      []SourcesState      `json:"sources"`
}

type DestinationsState struct {
	Hosts           []string               `json:"hosts"`
	Methods         []string               `json:"methods"`
	Ports           []float64              `json:"ports"`
	HttpHeaderMatch []HttpHeaderMatchState `json:"http_header_match"`
}

type HttpHeaderMatchState struct {
	HeaderName string `json:"header_name"`
	RegexMatch string `json:"regex_match"`
}

type SourcesState struct {
	IpBlocks   []string `json:"ip_blocks"`
	Principals []string `json:"principals"`
}

type TimeoutsState struct {
	Create string `json:"create"`
	Delete string `json:"delete"`
	Update string `json:"update"`
}
