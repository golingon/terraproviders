// CODE GENERATED BY github.com/golingon/lingon. DO NOT EDIT.

package google_network_security_authorization_policy

import (
	terra "github.com/golingon/lingon/pkg/terra"
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
)

type Rules struct {
	// RulesDestinations: min=0
	Destinations []RulesDestinations `hcl:"destinations,block" validate:"min=0"`
	// RulesSources: min=0
	Sources []RulesSources `hcl:"sources,block" validate:"min=0"`
}

type RulesDestinations struct {
	// Hosts: list of string, required
	Hosts terra.ListValue[terra.StringValue] `hcl:"hosts,attr" validate:"required"`
	// Methods: list of string, required
	Methods terra.ListValue[terra.StringValue] `hcl:"methods,attr" validate:"required"`
	// Ports: list of number, required
	Ports terra.ListValue[terra.NumberValue] `hcl:"ports,attr" validate:"required"`
	// RulesDestinationsHttpHeaderMatch: optional
	HttpHeaderMatch *RulesDestinationsHttpHeaderMatch `hcl:"http_header_match,block"`
}

type RulesDestinationsHttpHeaderMatch struct {
	// HeaderName: string, required
	HeaderName terra.StringValue `hcl:"header_name,attr" validate:"required"`
	// RegexMatch: string, required
	RegexMatch terra.StringValue `hcl:"regex_match,attr" validate:"required"`
}

type RulesSources struct {
	// IpBlocks: list of string, optional
	IpBlocks terra.ListValue[terra.StringValue] `hcl:"ip_blocks,attr"`
	// Principals: list of string, optional
	Principals terra.ListValue[terra.StringValue] `hcl:"principals,attr"`
}

type Timeouts struct {
	// Create: string, optional
	Create terra.StringValue `hcl:"create,attr"`
	// Delete: string, optional
	Delete terra.StringValue `hcl:"delete,attr"`
	// Update: string, optional
	Update terra.StringValue `hcl:"update,attr"`
}

type RulesAttributes struct {
	ref terra.Reference
}

func (r RulesAttributes) InternalRef() (terra.Reference, error) {
	return r.ref, nil
}

func (r RulesAttributes) InternalWithRef(ref terra.Reference) RulesAttributes {
	return RulesAttributes{ref: ref}
}

func (r RulesAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return r.ref.InternalTokens()
}

func (r RulesAttributes) Destinations() terra.ListValue[RulesDestinationsAttributes] {
	return terra.ReferenceAsList[RulesDestinationsAttributes](r.ref.Append("destinations"))
}

func (r RulesAttributes) Sources() terra.ListValue[RulesSourcesAttributes] {
	return terra.ReferenceAsList[RulesSourcesAttributes](r.ref.Append("sources"))
}

type RulesDestinationsAttributes struct {
	ref terra.Reference
}

func (d RulesDestinationsAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d RulesDestinationsAttributes) InternalWithRef(ref terra.Reference) RulesDestinationsAttributes {
	return RulesDestinationsAttributes{ref: ref}
}

func (d RulesDestinationsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return d.ref.InternalTokens()
}

func (d RulesDestinationsAttributes) Hosts() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](d.ref.Append("hosts"))
}

func (d RulesDestinationsAttributes) Methods() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](d.ref.Append("methods"))
}

func (d RulesDestinationsAttributes) Ports() terra.ListValue[terra.NumberValue] {
	return terra.ReferenceAsList[terra.NumberValue](d.ref.Append("ports"))
}

func (d RulesDestinationsAttributes) HttpHeaderMatch() terra.ListValue[RulesDestinationsHttpHeaderMatchAttributes] {
	return terra.ReferenceAsList[RulesDestinationsHttpHeaderMatchAttributes](d.ref.Append("http_header_match"))
}

type RulesDestinationsHttpHeaderMatchAttributes struct {
	ref terra.Reference
}

func (hhm RulesDestinationsHttpHeaderMatchAttributes) InternalRef() (terra.Reference, error) {
	return hhm.ref, nil
}

func (hhm RulesDestinationsHttpHeaderMatchAttributes) InternalWithRef(ref terra.Reference) RulesDestinationsHttpHeaderMatchAttributes {
	return RulesDestinationsHttpHeaderMatchAttributes{ref: ref}
}

func (hhm RulesDestinationsHttpHeaderMatchAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return hhm.ref.InternalTokens()
}

func (hhm RulesDestinationsHttpHeaderMatchAttributes) HeaderName() terra.StringValue {
	return terra.ReferenceAsString(hhm.ref.Append("header_name"))
}

func (hhm RulesDestinationsHttpHeaderMatchAttributes) RegexMatch() terra.StringValue {
	return terra.ReferenceAsString(hhm.ref.Append("regex_match"))
}

type RulesSourcesAttributes struct {
	ref terra.Reference
}

func (s RulesSourcesAttributes) InternalRef() (terra.Reference, error) {
	return s.ref, nil
}

func (s RulesSourcesAttributes) InternalWithRef(ref terra.Reference) RulesSourcesAttributes {
	return RulesSourcesAttributes{ref: ref}
}

func (s RulesSourcesAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return s.ref.InternalTokens()
}

func (s RulesSourcesAttributes) IpBlocks() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](s.ref.Append("ip_blocks"))
}

func (s RulesSourcesAttributes) Principals() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](s.ref.Append("principals"))
}

type TimeoutsAttributes struct {
	ref terra.Reference
}

func (t TimeoutsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t TimeoutsAttributes) InternalWithRef(ref terra.Reference) TimeoutsAttributes {
	return TimeoutsAttributes{ref: ref}
}

func (t TimeoutsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return t.ref.InternalTokens()
}

func (t TimeoutsAttributes) Create() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("create"))
}

func (t TimeoutsAttributes) Delete() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("delete"))
}

func (t TimeoutsAttributes) Update() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("update"))
}

type RulesState struct {
	Destinations []RulesDestinationsState `json:"destinations"`
	Sources      []RulesSourcesState      `json:"sources"`
}

type RulesDestinationsState struct {
	Hosts           []string                                `json:"hosts"`
	Methods         []string                                `json:"methods"`
	Ports           []float64                               `json:"ports"`
	HttpHeaderMatch []RulesDestinationsHttpHeaderMatchState `json:"http_header_match"`
}

type RulesDestinationsHttpHeaderMatchState struct {
	HeaderName string `json:"header_name"`
	RegexMatch string `json:"regex_match"`
}

type RulesSourcesState struct {
	IpBlocks   []string `json:"ip_blocks"`
	Principals []string `json:"principals"`
}

type TimeoutsState struct {
	Create string `json:"create"`
	Delete string `json:"delete"`
	Update string `json:"update"`
}
